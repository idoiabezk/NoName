calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = slopeB,
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Print the data frame with calibration results
print(calibration_resultsB)
# Arrange plots in a grid
calibration_curves_gridB <- plotsB[[1]]
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Store the calibration results in the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = slopeB,
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Store the calibration results in the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = slopeB,
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Store the calibration results in the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = slopeB,
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
# Print the grid of calibration curves
calibration_curves_gridB
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Molecule = molecule_name,
Slope = slopeA,
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_grid <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
---
output: html_document
#Clean the environment
rm(list = ls())
TESTING<-read_excel("F:/LINKOPING/Manuscripts/Skyline/Skyline/TESTING.xlsx")|>
mutate(`Analyte Concentration`= as.numeric(`Analyte Concentration`))
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(Molecule = character(),
Slope = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Molecule = molecule_name,
Slope = slopeA,
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_grid <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsB <- list()
calibration_resultsB <- data.frame(Molecule = character(),
Slope = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Store the calibration results in the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = slopeB,
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
# Print the data frame with calibration results
print(calibration_resultsB)
# Arrange plots in a grid
calibration_curves_gridB <- plotsB[[1]]
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
View(TESTING)
#Clean the environment
rm(list = ls())
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(Molecule = character(),
Slope = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Molecule = molecule_name,
Slope = slopeA,
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
#Clean the environment
rm(list = ls())
TESTING<-read_excel("F:/LINKOPING/Manuscripts/Skyline/Skyline/TESTING.xlsx")|>
mutate(`Analyte Concentration`= as.numeric(`Analyte Concentration`))
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(Molecule = character(),
Slope = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Molecule = molecule_name,
Slope = slopeA,
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsB <- list()
calibration_resultsB <- data.frame(Molecule = character(),
Slope = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Store the calibration results in the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = slopeB,
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
# Print the data frame with calibration results
print(calibration_resultsB)
# Arrange plots in a grid
calibration_curves_gridB <- plotsB[[1]]
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
View(calibration_resultsB)
View(calibration_resultsA)
install.packages("rsconnect")
