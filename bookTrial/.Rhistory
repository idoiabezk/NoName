View(calibration_resultsA)
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsB <- list()
calibration_resultsB <- data.frame(Molecule = character(),
Slope = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Store the calibration results in the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(Molecule = molecule_name,
Slope = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
# Print the data frame with calibration results
print(calibration_resultsB)
# Arrange plots in a grid
calibration_curves_gridB <- plotsB[[1]]
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Reference_standard = `Replicate Name`,
Chain_length = "C" [i],
Type = "SCCPs",
Homologue = molecule_name,
Slope = round(slopeA),
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
View(calibration_resultsA)
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Reference_standard = TESTING$`Replicate Name`,
Chain_length = "C" [i],
Type = "SCCPs",
Homologue = molecule_name,
Slope = round(slopeA),
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
View(calibration_resultsA)
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Reference_standard = A,
Chain_length = "C" [i],
Type = "SCCPs",
Homologue = molecule_name,
Slope = round(slopeA),
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
View(calibration_resultsA)
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Reference_standard = "A",
Chain_length = "C" [i],
Type = "SCCPs",
Homologue = molecule_name,
Slope = round(slopeA),
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Store the calibration results in the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(Reference_standard = "A",
Chain_length = "C" [i],
Type = "SCCPs",
Homologue = molecule_name,
Response_factor = round(slopeA),
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
View(calibration_resultsA)
Statistics_Kumla_20200408 |>  select(Year, PFOA) |> filter(Year== 2017)
ggplot(data = Statistics_Kumla_20200408) +
geom_point(mapping = aes(x = PFOA, y = PFBA, size = PFOS), colour = "black")
ggplot(data = Statistics_Kumla_20200408) +
geom_point(mapping = aes(x = PFOA, y = PFBA, size = PFOS), colour = "black") +
scale_size_continuous(
name = "PFOS Description",
breaks = c(10, 50, 100, 500, 1000),  # Adjust the breaks to include more values
labels = c("10", "50", "100", "500", "1000")  # Adjust labels accordingly
)
ggplot(data = Statistics_Kumla_20200408) +
geom_point(mapping = aes(x = PFOA, y = PFBA, size = PFOS), colour = "black") +
scale_size_continuous(
name = "PFOS Description",
breaks = c(10, 50, 100, 500, 1000),  # Adjust the breaks to include more values
labels = c("10", "50", "100", "500", "1000")  # Adjust labels accordingly
) +
geom_smooth(mapping = aes(x = PFOA, y = PFOS),
method = "lm",
se = FALSE,
colour = "orange",
size = 2) +
geom_smooth(mapping = aes(x = PFOA, y = PFOS),
method = "loess",
se = FALSE,
colour = "green",
size = 2) +
geom_point(mapping = aes(x = PFOA, y = PFBS, # new mapping
size = PFBS), # size of points according to PFBS values
colour = "purple") + # colour outside of mappings
theme_classic() # This theme will remove the background colours and lines
PFAS_insects_long <- Statistics_Kumla_20200408 %>% # shortcut for pipe Ctrl + shift + M
pivot_longer(cols = PFBA:PFOA, # select all columns from PFBA to sum_21PFAS
names_to = "somePFAS", # name of the new column
values_to = "Conc") %>%  #name of the values from PFBA:sum_21PFAS
mutate(somePFAS = as.factor(somePFAS)) #make PFAS column a factor variable
#check the PFAS group names
PFAS_insects_long |> group_by(somePFAS) |> tally() |> view()
# select PFOS isomers
PFOS_branched <- c("1-PFOS 419/169", "3/4/5-PFOS80/98.9")
PFAS_insects_long |>
filter(Group != "Water") |> #remove all water samples to only include solid samples
filter(str_detect(somePFAS, "sum_", negate = TRUE)) |> #remove all sum of PFAS using the argument: negate=TRUE
ggplot(aes(x = somePFAS, y = Conc)) +
geom_point() +
geom_boxplot() +
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
PFAS_insects_long |> mutate(Color = ifelse(Conc > 50, "orange", "black")) |>
ggplot(aes(x = somePFAS, y = Conc)) +
geom_point(color = Color) +
geom_boxplot() + #ifelse(test, yes, no)
scale_color_identity() +  # Use scale_color_identity to override the default color mapping
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
PFAS_insects_long |> mutate(Color = ifelse(Conc > 50, "orange", "black")) |>
ggplot(aes(x = somePFAS, y = Conc)) +
geom_point(color = ~Color) +
geom_boxplot() + #ifelse(test, yes, no)
scale_color_identity() +  # Use scale_color_identity to override the default color mapping
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
PFAS_insects_long |> mutate(Color = ifelse(Conc > 50, "orange", "black")) |>
ggplot(aes(x = somePFAS, y = Conc)) +
geom_point() +
geom_boxplot() + #ifelse(test, yes, no)
scale_color_identity() +  # Use scale_color_identity to override the default color mapping
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
ggplot(data = PFAS_insects_long, aes(x = somePFAS, y = Conc)) +
geom_point(color = ifelse(as.numeric(somePFAS) < 0.007, "orange", "black")) +
#geom_boxplot() +
#scale_color_identity() +  # Use scale_color_identity to override the default color mapping
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
PFAS_insects_long |> mutate(Color = ifelse(Conc > 50, "orange", "black")) |>
ggplot(aes(x = somePFAS, y = Conc)) +
#geom_point(color = ~Color) +
geom_boxplot() + #ifelse(test, yes, no)
scale_color_identity() +  # Use scale_color_identity to override the default color mapping
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
ggplot(data = PFAS_insects_long, aes(x = somePFAS, y = Conc)) +
#geom_point(color = ifelse(as.numeric(somePFAS) < 0.007, "orange", "black")) +
#geom_boxplot() +
#scale_color_identity() +  # Use scale_color_identity to override the default color mapping
theme_classic() +
ylab("Concentration of PFAS (ng/g) in solid samples")
