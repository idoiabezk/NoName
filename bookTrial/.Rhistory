}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
View(filtered_dataB)
View(calibration_resultsB)
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
############################################################## B standards
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsB <- list()
calibration_resultsB <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
View(calibration_resultsB)
# Print the grid of calibration curves
calibration_curves_gridB
# Print the data frame with calibration results
print(calibration_resultsB)
# Arrange plots in a grid
calibration_curves_gridB <- plotsB[[1]]
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
combined_df <- rbind(calibration_resultsA, calibration_resultsB)
View(combined_df)
View(filtered_dataB)
#Clean the environment
rm(list = ls())
TESTING<-read_excel("F:/LINKOPING/Manuscripts/Skyline/Skyline/TESTING.xlsx")|>
mutate(`Analyte Concentration`= as.numeric(`Analyte Concentration`))
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsA <- list()
calibration_resultsA <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataA <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelA <- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)
# Extract slope and intercept from the model
slopeA <- coef(lm_modelA)[2]
interceptA <- coef(lm_modelA)[1]
# Calculate R-squared
R_squaredA <- summary(lm_modelA)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsA <- rbind(calibration_resultsA,
data.frame(STD_code = paste("A-", type),
Reference_standard = paste(type, "C", i, "Cl%", "52"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeA),
Intercept = interceptA,
R_squared = R_squaredA))
# Create plot for the current molecule
plotA <- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "orange",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsA[[paste("Molecule", molecule_name)]] <- plotA
}
}
}
# Print the data frame with calibration results
print(calibration_resultsA)
# Arrange plots in a grid
calibration_curves_gridA <- plotsA[[1]]
for (i in 2:length(plotsA)) {
calibration_curves_gridA <- calibration_curves_gridA + plotsA[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridA
############################################################## B standards
# Function to create molecule names
create_molecule_name <- function(i, j) {
molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
return(molecule_name)
}
# Create an empty list to store plots and calibration results
plotsB <- list()
calibration_resultsB <- data.frame(STD_code = character(),
Reference_standard = character(),
Chain_length = character(),
Type = character(),
Homologue = character(),
Response_factor = numeric(),
Intercept = numeric(),
R_squared = numeric(),
stringsAsFactors = FALSE)
# Define the range of i and j
i_values <- 11
j_values <- 3:11
# Nested loops to iterate over i and j
for (i in i_values) {
for (j in j_values) {
# Create molecule name
molecule_name <- create_molecule_name(i, j)
# Filter data for the current molecule
filtered_dataB <- TESTING |>
filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B")
# Check if there are any non-NA cases in the filtered data
if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {
cat("No valid cases for fitting the model for molecule:", molecule_name, "\n")
} else {
# Fit linear model to the data
lm_modelB <- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)
# Extract slope and intercept from the model
slopeB <- coef(lm_modelB)[2]
interceptB <- coef(lm_modelB)[1]
# Calculate R-squared
R_squaredB <- summary(lm_modelB)$r.squared
# Determine the type based on the value of i
if (i >= 10 && i <= 13) {
type <- "SCCPs"
} else if (i >= 14 && i <= 17) {
type <- "MCCPs"
} else if (i >= 18 && i <= 30) {
type <- "LCCPs"
} else {
type <- "Unknown"
}
# Fill the data frame
calibration_resultsB <- rbind(calibration_resultsB,
data.frame(STD_code = paste("B-", type),
Reference_standard = paste(type, "C", i, "Cl%", "57"),
Chain_length = paste("C",i),
Type = type,
Homologue = molecule_name,
Response_factor = round(slopeB),
Intercept = interceptB,
R_squared = R_squaredB))
# Create plot for the current molecule
plotB <- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +
geom_point() +
geom_smooth(method = "lm",
se = FALSE,
colour = "purple",
size = 1) +
theme_classic() +
ylab("Area") +
ggtitle(paste("Molecule:", molecule_name))
# Store the plot in the list
plotsB[[paste("Molecule", molecule_name)]] <- plotB
}
}
}
# Print the data frame with calibration results
print(calibration_resultsB)
# Arrange plots in a grid
calibration_curves_gridB <- plotsB[[1]]
for (i in 2:length(plotsB)) {
calibration_curves_gridB <- calibration_curves_gridB + plotsB[[i]]
}
# Print the grid of calibration curves
calibration_curves_gridB
combined_df <- rbind(calibration_resultsA, calibration_resultsB)
View(combined_df)
