[
  {
    "objectID": "Project.html#correct-the-instrumental-with-the-internal-standard-is",
    "href": "Project.html#correct-the-instrumental-with-the-internal-standard-is",
    "title": "8  Project",
    "section": "8.1 Correct the instrumental with the internal standard (IS):",
    "text": "8.1 Correct the instrumental with the internal standard (IS):\n\n#Clean the environment\nrm(list = ls()) \n\n#Load the libraries\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.4\n✔ ggplot2   3.4.3     ✔ stringr   1.5.0\n✔ lubridate 1.9.2     ✔ tibble    3.2.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(readxl)\nlibrary(patchwork)\n\n#Load the file\nGC_qToF_CPsFoodResults&lt;-read_excel(\"F:/OREBRO/CP analysis/Food project/Result/Skyline/GC_qToF_CPsFoodResults.xlsx\")\n\n#Wide the data so each sample is in one row\nGC_qToF_CPsFoodResultsB &lt;- GC_qToF_CPsFoodResults |&gt;  \n  filter(Quantitative == \"YES\") |&gt; \n  pivot_wider(id_cols = `Replicate Name`,\n              names_from = Molecule, # name of the new column\n              values_from = Area #name of the values for the new columns\n             ) #data type       \n\n#Make the data in the data frame numeric\npattern &lt;- \"^C\\\\d+\" # This pattern matches column names starting with \"C\" followed by numbers\nGC_qToF_CPsFoodResultsB &lt;- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), as.numeric) # Apply as.numeric() to columns matching the pattern\nGC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)# Define the IS as numeric \n\n#Divide the area of the homologues by the IS\nCorrectedArea &lt;- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), \n                           ~ . / GC_qToF_CPsFoodResultsB$IS) #It will now do it for all the columns that have the pattern (start the name with \"C\")"
  },
  {
    "objectID": "Project.html#calculate-the-recovery",
    "href": "Project.html#calculate-the-recovery",
    "title": "8  Project",
    "section": "8.2 Calculate the recovery",
    "text": "8.2 Calculate the recovery\n\n# Define the RS as numeric\nGC_qToF_CPsFoodResultsB$RS = as.numeric(GC_qToF_CPsFoodResultsB$RS) \nGC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)\n\n##########Filter and prepare the standards that we want to compare to\nStd&lt;-GC_qToF_CPsFoodResultsB|&gt;  \n  select(`Replicate Name`, IS, RS)|&gt; #Select the columns that we need\n  filter(str_detect(`Replicate Name`, \"Std\", negate = FALSE))|&gt; #Select the standards\n  mutate(RatioStd = IS / RS) |&gt; #Calculate the IS/RS area for the standards \n  summarize(AverageRatio = mean(RatioStd, na.rm = TRUE)) #Calculate the average of the three standards\n\n##############Calculate the recovery\nGC_qToF_CPsFoodResultsB&lt;-GC_qToF_CPsFoodResultsB|&gt;\n  filter(str_detect(`Replicate Name`, \"9_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"10_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"11_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"12_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"13_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"14_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"15_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"16_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"17_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"Std\", negate = TRUE))|&gt;#Exclude the calibration standards\n  \n  mutate(RatioSample= IS / RS) |&gt; #Divide IS/RS for all samples\n  mutate(Recovery=RatioSample/as.numeric(Std))|&gt; #Divide each sample ratio of IS/RS by the average ratio of the standards\n  mutate(RecoveryPerc=Recovery*100) #The recovery in percentage\n\n\n#################Plotting the recovery\n\n# Define colors based on conditions: less than 50% red and above green\nGC_qToF_CPsFoodResultsB$color &lt;- ifelse(GC_qToF_CPsFoodResultsB$RecoveryPerc &gt; 50, \"#CD3333\", \"#9ACD32\")\n\n#Reorder the samples\nGC_qToF_CPsFoodResultsB$`Replicate Name` &lt;- factor(GC_qToF_CPsFoodResultsB$`Replicate Name`, levels = c(\"1\", \"1B\", \"1C\", \"2\", \"3\", \"4A\", \"4B\", \"5A\", \"5B\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"18\", \"19\", \"20\", \"D1\", \"D2\", \"D3\", \"21 Na2SO4\", \"23 24 FB\", \"25 LB\", \"26 LB\", \"27 LB\", \"28 LB\", \"29 MLB\"))\n\n# Bar plot\nggplot(GC_qToF_CPsFoodResultsB, aes(x = `Replicate Name`, y = RecoveryPerc, fill = color)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  scale_fill_manual(values = c(\"#CD3333\", \"#9ACD32\"), guide = FALSE) +\n  labs(x = \"Replicate Name\", y = \"RECOVERY\", title = \"RECOVERY\") +\n  theme_minimal()\n\nWarning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in\nggplot2 3.3.4.\nℹ Please use \"none\" instead."
  },
  {
    "objectID": "Project.html#prepare-the-single-chain-standards",
    "href": "Project.html#prepare-the-single-chain-standards",
    "title": "8  Project",
    "section": "8.3 Prepare the single chain standards",
    "text": "8.3 Prepare the single chain standards\nBefore quantifying PCAs in R by the deconvolution method, I need to prepare a “calibration” excel to input in the script. In this Excel one calibration curve is built by linear regression for each PCA homologue in each standard\n\n8.3.1 Build the calibration curves in R studio:\n\n#Load the file\n\nTESTING&lt;-read_excel(\"F:/LINKOPING/Manuscripts/Skyline/Skyline/TESTING.xlsx\")|&gt;\nmutate(`Analyte Concentration`= as.numeric(`Analyte Concentration`))\n\n######Build the calibration curve for one PCA homologue\nTESTING |&gt;\n  select(`Replicate Name`, Molecule, `Isotope Label Type`, `Normalized Area`, `Analyte Concentration`) |&gt;#Select the columns that we need\n  filter(`Isotope Label Type`== \"Quan\") |&gt; #Filter for the Quan\n  filter(`Molecule` == \"C11H19Cl5\")|&gt; #Filter for one PCA homologue\n  filter(str_detect(`Replicate Name`, \"11_57_\", negate = TRUE)) |&gt; #remove all the other standards \n\n  ggplot(aes(x = `Analyte Concentration`, y = `Normalized Area`)) + #Plot the scatter plot\n  geom_point() +\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = FALSE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n  theme_classic() +\n  ylab(\"Normalized Area\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n###################################################################################################################\n##############Normalized area is missing some values in the data frame so, I tried with the Area instead to see if the code was correct\n###################################################################################################################\n\n\nTESTING |&gt;  \n  select(`Replicate Name`, Molecule, `Isotope Label Type`, Area, `Analyte Concentration`) |&gt; #Select the columns that we need\n  filter(`Isotope Label Type`== \"Quan\") |&gt; #Filter for the Quan\n  filter(`Molecule` == \"C11H19Cl5\")|&gt; #Filter for one PCA homologue\n  filter(str_detect(`Replicate Name`, \"11_57_\", negate = TRUE)) |&gt; #remove all the other standards \n\n  ggplot(aes(x = `Analyte Concentration`, y = Area)) + #Plot the scatter plot\n  geom_point() +\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = FALSE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n  theme_classic() +\n  ylab(\"Area\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n#################################################################################################################\n###################################Try to generate a loop for the calibration curve, so I don't need to write the homologue and the standards for every calibration curve###########################################################\n#################################################################################################################\n\n\n#Two standards per each molecule -&gt; each molecule one calibration curve for standard \"A\" and one for \"B\"\n\n###########CALIBRATION FOR STANDARDS \"A\" ##################################################\n\n# Function to create molecule names\ncreate_molecule_name &lt;- function(i, j) {\n  molecule_name &lt;- paste0(\"C\", i, \"H\", (2*i)+2-j, \"Cl\", j)\n  return(molecule_name)\n}\n\n# Create an empty list to store plots and calibration results\nplotsA &lt;- list()\ncalibration_resultsA &lt;- data.frame(Molecule = character(),\n                                  Slope = numeric(),\n                                  Intercept = numeric(),\n                                  R_squared = numeric(),\n                                  stringsAsFactors = FALSE)\n\n# Define the range of i and j\ni_values &lt;- 11\nj_values &lt;- 3:11\n\n# Nested loops to iterate over i and j\nfor (i in i_values) {\n  for (j in j_values) {\n    # Create molecule name\n    molecule_name &lt;- create_molecule_name(i, j)\n    \n    # Filter data for the current molecule\n    filtered_dataA &lt;- TESTING |&gt;\n      filter(`Isotope Label Type` == \"Quan\", Molecule == molecule_name, Note == \"A\") \n    \n    # Check if there are any non-NA cases in the filtered data\n    if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {\n      cat(\"No valid cases for fitting the model for molecule:\", molecule_name, \"\\n\")\n    } else {\n      # Fit linear model to the data\n      lm_modelA &lt;- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)\n      \n      # Extract slope and intercept from the model\n      slopeA &lt;- coef(lm_modelA)[2]\n      interceptA &lt;- coef(lm_modelA)[1]\n      \n      # Calculate R-squared\n      R_squaredA &lt;- summary(lm_modelA)$r.squared\n      \n      # Store the calibration results in the data frame\n      calibration_resultsA &lt;- rbind(calibration_resultsA, \n                                   data.frame(Molecule = molecule_name,\n                                              Slope = slopeA,\n                                              Intercept = interceptA,\n                                              R_squared = R_squaredA))\n      \n      # Create plot for the current molecule\n      plotA &lt;- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +\n        geom_point() +\n        geom_smooth(method = \"lm\", \n                    se = FALSE, \n                    colour = \"orange\",\n                    size = 1) +\n        theme_classic() +\n        ylab(\"Area\") +\n        ggtitle(paste(\"Molecule:\", molecule_name))\n      \n      # Store the plot in the list\n      plotsA[[paste(\"Molecule\", molecule_name)]] &lt;- plotA\n    }\n  }\n}\n\nNo valid cases for fitting the model for molecule: C11H21Cl3 \nNo valid cases for fitting the model for molecule: C11H14Cl10 \nNo valid cases for fitting the model for molecule: C11H13Cl11 \n\n# Print the data frame with calibration results\nprint(calibration_resultsA)\n\n                          Molecule        Slope   Intercept R_squared\n`Analyte Concentration`  C11H20Cl4     55.49065   -128.4533 1.0000000\n`Analyte Concentration`1 C11H19Cl5   3504.14074   7551.7035 0.8560300\n`Analyte Concentration`2 C11H18Cl6 200370.33017 -65240.9809 0.9953752\n`Analyte Concentration`3 C11H17Cl7 111547.20139 -69087.2219 0.5773315\n`Analyte Concentration`4 C11H16Cl8  17455.53491  -3024.9974 0.9960371\n`Analyte Concentration`5 C11H15Cl9   -599.32315   5506.1035 0.3937749\n\n# Arrange plots in a grid\ncalibration_curves_gridA &lt;- plotsA[[1]]\nfor (i in 2:length(plotsA)) {\n  calibration_curves_gridA &lt;- calibration_curves_gridA + plotsA[[i]]\n}\n\n# Print the grid of calibration curves\ncalibration_curves_gridA\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n###########CALIBRATION FOR STANDARDS \"B\" ##################################################\n\n# Function to create molecule names\ncreate_molecule_name &lt;- function(i, j) {\n  molecule_name &lt;- paste0(\"C\", i, \"H\", (2*i)+2-j, \"Cl\", j)\n  return(molecule_name)\n}\n\n# Create an empty list to store plots and calibration results\nplotsB &lt;- list()\ncalibration_resultsB &lt;- data.frame(Molecule = character(),\n                                  Slope = numeric(),\n                                  Intercept = numeric(),\n                                  R_squared = numeric(),\n                                  stringsAsFactors = FALSE)\n\n# Define the range of i and j\ni_values &lt;- 11\nj_values &lt;- 3:11\n\n# Nested loops to iterate over i and j\nfor (i in i_values) {\n  for (j in j_values) {\n    # Create molecule name\n    molecule_name &lt;- create_molecule_name(i, j)\n    \n    # Filter data for the current molecule\n    filtered_dataB &lt;- TESTING |&gt;\n      filter(`Isotope Label Type` == \"Quan\", Molecule == molecule_name, Note == \"B\") \n    \n    # Check if there are any non-NA cases in the filtered data\n    if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {\n      cat(\"No valid cases for fitting the model for molecule:\", molecule_name, \"\\n\")\n    } else {\n      # Fit linear model to the data\n      lm_modelB &lt;- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)\n      \n      # Extract slope and intercept from the model\n      slopeB &lt;- coef(lm_modelB)[2]\n      interceptB &lt;- coef(lm_modelB)[1]\n      \n      # Calculate R-squared\n      R_squaredB &lt;- summary(lm_modelB)$r.squared\n      \n      # Store the calibration results in the data frame\n      calibration_resultsB &lt;- rbind(calibration_resultsB, \n                                   data.frame(Molecule = molecule_name,\n                                              Slope = slopeB,\n                                              Intercept = interceptB,\n                                              R_squared = R_squaredB))\n      \n      # Create plot for the current molecule\n      plotB &lt;- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +\n        geom_point() +\n        geom_smooth(method = \"lm\", \n                    se = FALSE, \n                    colour = \"purple\",\n                    size = 1) +\n        theme_classic() +\n        ylab(\"Area\") +\n        ggtitle(paste(\"Molecule:\", molecule_name))\n      \n      # Store the plot in the list\n      plotsB[[paste(\"Molecule\", molecule_name)]] &lt;- plotB\n    }\n  }\n}\n\nNo valid cases for fitting the model for molecule: C11H21Cl3 \nNo valid cases for fitting the model for molecule: C11H20Cl4 \nNo valid cases for fitting the model for molecule: C11H13Cl11 \n\n# Print the data frame with calibration results\nprint(calibration_resultsB)\n\n                           Molecule       Slope    Intercept R_squared\n`Analyte Concentration`   C11H19Cl5    281.5607    -100.5869 0.9985452\n`Analyte Concentration`1  C11H18Cl6  69945.1458  -21222.1094 0.9982298\n`Analyte Concentration`2  C11H17Cl7 684163.4231 -345883.4802 0.9899243\n`Analyte Concentration`3  C11H16Cl8 527968.6603 -129197.1053 0.9984855\n`Analyte Concentration`4  C11H15Cl9 117684.0279  -24610.5452 0.9985014\n`Analyte Concentration`5 C11H14Cl10   8783.9772   -3011.7311 0.9939191\n\n# Arrange plots in a grid\ncalibration_curves_gridB &lt;- plotsB[[1]]\nfor (i in 2:length(plotsB)) {\n  calibration_curves_gridB &lt;- calibration_curves_gridB + plotsB[[i]]\n}\n\n# Print the grid of calibration curves\ncalibration_curves_gridB\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\nRemoved 1 rows containing missing values (`geom_point()`).\n\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n8.3.2 The code for Excel:\n\n#Response factor of each homologue per 1 ng/µL\n#=ROUND(SLOPE(INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MAX(N4:U4);N4:U4;0));TRUE);INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MAX(N4:U4);N4:U4;0));TRUE));0)\n############Note: N4:U4 are the values of the corrected peak are of the standards\n\n\n#The result from the previous row to this one\n#=IF(ISERROR(W4);0;W4)"
  }
]