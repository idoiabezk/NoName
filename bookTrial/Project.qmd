---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Project

**The main objective of this project is to automatize the workflow of the data treatment for the quantification of Polychlorianted alkanes (PCAs).**

## Correct the instrumental with the internal standard (IS):

```{r}

#Clean the environment
rm(list = ls()) 

#Load the libraries
library(dplyr)
library(tidyr)
library(tidyverse)
library(readxl)

#Load the file
GC_qToF_CPsFoodResults<-read_excel("F:/OREBRO/CP analysis/Food project/Result/Skyline/GC_qToF_CPsFoodResults.xlsx")

#Wide the data so each sample is in one row
GC_qToF_CPsFoodResultsB <- GC_qToF_CPsFoodResults |>  
  filter(Quantitative == "YES") |> 
  pivot_wider(id_cols = `Replicate Name`,
              names_from = Molecule, # name of the new column
              values_from = Area #name of the values for the new columns
             ) #data type       

#Make the data in the data frame numeric
pattern <- "^C\\d+" # This pattern matches column names starting with "C" followed by numbers
GC_qToF_CPsFoodResultsB <- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), as.numeric) # Apply as.numeric() to columns matching the pattern
GC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)# Define the IS as numeric 

#Divide the area of the homologues by the IS
CorrectedArea <- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), 
                           ~ . / GC_qToF_CPsFoodResultsB$IS) #It will now do it for all the columns that have the pattern (start the name with "C")

```

## Calculate the recovery

```{r}
# Define the RS as numeric
GC_qToF_CPsFoodResultsB$RS = as.numeric(GC_qToF_CPsFoodResultsB$RS) 
GC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)

##########Filter and prepare the standards that we want to compare to
Std<-GC_qToF_CPsFoodResultsB|>  
  select(`Replicate Name`, IS, RS)|> #Select the columns that we need
  filter(str_detect(`Replicate Name`, "Std", negate = FALSE))|> #Select the standards
  mutate(RatioStd = IS / RS) |> #Calculate the IS/RS area for the standards 
  summarize(AverageRatio = mean(RatioStd, na.rm = TRUE)) #Calculate the average of the three standards

##############Calculate the recovery
GC_qToF_CPsFoodResultsB<-GC_qToF_CPsFoodResultsB|>
  filter(str_detect(`Replicate Name`, "9_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "10_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "11_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "12_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "13_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "14_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "15_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "16_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "17_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "Std", negate = TRUE))|>#Exclude the calibration standards
  
  mutate(RatioSample= IS / RS) |> #Divide IS/RS for all samples
  mutate(Recovery=RatioSample/as.numeric(Std))|> #Divide each sample ratio of IS/RS by the average ratio of the standards
  mutate(RecoveryPerc=Recovery*100) #The recovery in percentage


#################Plotting the recovery

# Define colors based on conditions: less than 50% red and above green
GC_qToF_CPsFoodResultsB$color <- ifelse(GC_qToF_CPsFoodResultsB$RecoveryPerc > 50, "#CD3333", "#9ACD32")

#Reorder the samples
GC_qToF_CPsFoodResultsB$`Replicate Name` <- factor(GC_qToF_CPsFoodResultsB$`Replicate Name`, levels = c("1", "1B", "1C", "2", "3", "4A", "4B", "5A", "5B", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "18", "19", "20", "D1", "D2", "D3", "21 Na2SO4", "23 24 FB", "25 LB", "26 LB", "27 LB", "28 LB", "29 MLB"))

# Bar plot
ggplot(GC_qToF_CPsFoodResultsB, aes(x = `Replicate Name`, y = RecoveryPerc, fill = color)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("#CD3333", "#9ACD32"), guide = FALSE) +
  labs(x = "Replicate Name", y = "RECOVERY", title = "RECOVERY") +
  theme_minimal()

```

## Prepare the single chain standards

Before quantifying PCAs in R by the deconvolution method, I need to prepare a "calibration" excel to input in the script. In this Excel one calibration curve is built by linear regression for each PCA homologue in each standard

### Build the calibration curves in R studio:

```{r}
#Load the file

TESTING<-read_excel("F:/LINKOPING/Manuscripts/Skyline/Skyline/TESTING.xlsx")|>
mutate(`Analyte Concentration`= as.numeric(`Analyte Concentration`))

######Build the calibration curve for one PCA homologue
TESTING |>
  select(`Replicate Name`, Molecule, `Isotope Label Type`, `Normalized Area`, `Analyte Concentration`) |>#Select the columns that we need
  filter(`Isotope Label Type`== "Quan") |> #Filter for the Quan
  filter(`Molecule` == "C11H19Cl5")|> #Filter for one PCA homologue
  filter(str_detect(`Replicate Name`, "11_57_", negate = TRUE)) |> #remove all the other standards 

  ggplot(aes(x = `Analyte Concentration`, y = `Normalized Area`)) + #Plot the scatter plot
  geom_point() +
  geom_smooth(method = "lm", # uses the linear regression model
              se = FALSE, # this will remove the confidence intervals
              colour = "orange",
              size = 2) +
  theme_classic() +
  ylab("Normalized Area")

###################################################################################################################
##############Normalized area is missing some values in the data frame so, I tried with the Area instead to see if the code was correct
###################################################################################################################


TESTING |>  
  select(`Replicate Name`, Molecule, `Isotope Label Type`, Area, `Analyte Concentration`) |> #Select the columns that we need
  filter(`Isotope Label Type`== "Quan") |> #Filter for the Quan
  filter(`Molecule` == "C11H19Cl5")|> #Filter for one PCA homologue
  filter(str_detect(`Replicate Name`, "11_57_", negate = TRUE)) |> #remove all the other standards 

  ggplot(aes(x = `Analyte Concentration`, y = Area)) + #Plot the scatter plot
  geom_point() +
  geom_smooth(method = "lm", # uses the linear regression model
              se = FALSE, # this will remove the confidence intervals
              colour = "orange",
              size = 2) +
  theme_classic() +
  ylab("Area")


#################################################################################################################
###################################Try to generate a loop for the calibration curve, so I don't need to write the homologue and the standards for every calibration curve###########################################################
#################################################################################################################


#Two standards per each molecule -> each molecule one calibration curve for standard "A" and one for "B"

###########CALIBRATION FOR STANDARDS "A" ##################################################

# Function to create molecule names
create_molecule_name <- function(i, j) {
  molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
  return(molecule_name)
}

# Create an empty list to store plots
plotsA <- list()


# Define the range of i and j
i_values <- 11 #in my data frame I only have the standard for C11, but otherwise it should be 9:30
j_values <- 3:11

# Nested loops to iterate over i and j
for (i in i_values) {
  for (j in j_values) {
    # Create molecule name
    molecule_name <- create_molecule_name(i, j)
    
    # Filter data for the current molecule
    filtered_data <- TESTING |>
      filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "A") 
    
    # Create plot for the current molecule
    plotA <- ggplot(filtered_data, aes(x = `Analyte Concentration`, y = Area)) +
      geom_point() +
      geom_smooth(method = "lm", 
                  se = FALSE, 
                  colour = "orange",
                  size = 2) +
      theme_classic() +
      ylab("Area") +
      ggtitle(paste("Molecule:", molecule_name))
    
    # Store the plot in the list
    plotsA[[paste("Molecule", molecule_name)]] <- plotA
  }
}

# Print the plots
plotsA



###########CALIBRATION FOR STANDARDS "B" ##################################################

# Function to create molecule names
create_molecule_name <- function(i, j) {
  molecule_name <- paste0("C", i, "H", (2*i)+2-j, "Cl", j)
  return(molecule_name)
}

# Create an empty list to store plots
plotsB <- list()

# Create an empty list to store regression results
regression_results <- list()

# Define the range of i and j
i_values <- 11 #in my data frame I only have the standard for C11, but otherwise it should be 9:30
j_values <- 3:11

# Nested loops to iterate over i and j
for (i in i_values) {
  for (j in j_values) {
    # Create molecule name
    molecule_name <- create_molecule_name(i, j)
    
    # Filter data for the current molecule
    filtered_data <- TESTING |>
      filter(`Isotope Label Type` == "Quan", Molecule == molecule_name, Note == "B") 
    
    # Create plot for the current molecule
    plotB <- ggplot(filtered_data, aes(x = `Analyte Concentration`, y = Area)) +
      geom_point() +
      geom_smooth(method = "lm", 
                  se = FALSE, 
                  colour = "orange",
                  size = 2) +
      theme_classic() +
      ylab("Area") +
      ggtitle(paste("Molecule:", molecule_name))
    
    # Store the plot in the list
    plotsB[[paste("Molecule", molecule_name)]] <- plotB
  }
}

# Print the plots
plotsB
```

### The code for Excel:

```{r}
#Response factor of each homologue per 1 ng/µL
#=ROUND(SLOPE(INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MAX(N4:U4);N4:U4;0));TRUE);INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MAX(N4:U4);N4:U4;0));TRUE));0)
############Note: N4:U4 are the values of the corrected peak are of the standards


#The result from the previous row to this one
#=IF(ISERROR(W4);0;W4)
```
