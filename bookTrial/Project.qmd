---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Project

**The main objective of this project is to automatize the workflow of the data treatment for the quantification of Polychlorianted alkanes (PCAs).**

## Correct the instrumental with the internal standard (IS):

```{r}

#Clean the environment
rm(list = ls()) 


#Load the libraries
library(dplyr)
library(tidyr)
library(tidyverse)

#Wide the data so each sample is in one row
GC_qToF_CPsFoodResultsB <- GC_qToF_CPsFoodResults |>  
  filter(Quantitative == "YES") |> 
  pivot_wider(id_cols = `Replicate Name`,
              names_from = Molecule, # name of the new column
              values_from = Area #name of the values for the new columns
             ) #data type       

#Make the data in the data frame numeric
pattern <- "^C\\d+" # This pattern matches column names starting with "C" followed by numbers
GC_qToF_CPsFoodResultsB <- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), as.numeric) # Apply as.numeric() to columns matching the pattern
GC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)# Define the IS as numeric 

#Divide the area of the homologues by the IS
CorrectedArea <- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), 
                           ~ . / GC_qToF_CPsFoodResultsB$IS) #It will now do it for all the columns that have the pattern (start the name with "C")

```

## Calculate the recovery

```{r}
# Define the RS as numeric
GC_qToF_CPsFoodResultsB$RS = as.numeric(GC_qToF_CPsFoodResultsB$RS) 
GC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)

####Filter for the standards that we want to compare to
Std<-GC_qToF_CPsFoodResultsB|>  
  select(`Replicate Name`, IS, RS)|> #Select the columns that we need
  filter(str_detect(`Replicate Name`, "Std", negate = FALSE))|> #Select the standards
  mutate(RatioStd = IS / RS) |> #Calculate the IS/RS area for the standards 
  summarize(AverageRatio = mean(RatioStd, na.rm = TRUE)) #Calculate the average of the three standards

####Calculate the recovery
GC_qToF_CPsFoodResultsD<-GC_qToF_CPsFoodResultsB|>
  filter(str_detect(`Replicate Name`, "9_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "10_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "11_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "12_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "13_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "14_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "15_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "16_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "17_", negate = TRUE))|>#Exclude the calibration standards
  filter(str_detect(`Replicate Name`, "Std", negate = TRUE))|>#Exclude the calibration standards
  
  mutate(RatioSample= IS / RS) |> #Divide IS/RS for all samples
  mutate(Recovery=RatioSample/33.71871)|> #Divide each sample ratio of IS/RS by the average ratio of the standards
  mutate(RecoveryPerc=Recovery*100) #The recovery in percentage


#######Plotting the recovery
# Define colors based on conditions: less than 50% red and above green
GC_qToF_CPsFoodResultsD$color <- ifelse(GC_qToF_CPsFoodResultsD$RecoveryPerc > 50, "#CD3333", "#9ACD32")

# Bar plot
ggplot(GC_qToF_CPsFoodResultsD, aes(x = `Replicate Name`, y = RecoveryPerc, fill = color)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("#CD3333", "#9ACD32"), guide = FALSE) +
  labs(x = "Replicate Name", y = "RECOVERY", title = "RECOVERY") +
  theme_minimal()


###################################################################################################################
#Dividing the IS by RS for the samples
GC_qToF_CPsFoodResultsB<-mutate(GC_qToF_CPsFoodResultsB,RatioSample= IS / RS) |> #Divide IS/RS for all samples
mutate(Recovery=RatioSample/Std)|>
mutate(RecoveryPerc=Recovery*100)
###############################It gives the values of the first row to all of them###############
###################################################################################################################


```




## Prepare the single chain standards

Before quantifying PCAs in R by the deconvolution method, I need to prepare a "calibration" excel to input in the script. In this Excel one calibration curve is built by linear regression for each PCA homologue in each standard

### Build the calibration curves in R studio:

-   

```{r}
#Select the columns that we need
TESTING |>  select(`Replicate Name`, Molecule, `Isotope Label Type`, `Normalized Area`, `Analyte Concentration`) |> filter(`Isotope Label Type`== "Quan") |> #Filter for the Quan
filter(`Molecule` == "C11H19Cl5")|> #Filter for one PCA homologue
filter(str_detect(`Replicate Name`, "11_57_", negate = TRUE)) |> #remove all the other standards 
ggplot(aes(x = `Analyte Concentration`, y = `Normalized Area`)) + #Plot the scater plot
  geom_point() +
  geom_smooth(method = "lm", # uses the linear regression model
              se = FALSE, # this will remove the confidence intervals
              colour = "orange",
              size = 2) +
  theme_classic() +
  ylab("Normalized Area")

##############Normalized area is missing some values in the data frame so, I tried with the Area instead to see if the code was correct

#Slect the columns that we need
TESTING |>  select(`Replicate Name`, Molecule, `Isotope Label Type`, Area, `Analyte Concentration`) |> filter(`Isotope Label Type`== "Quan") |> #Filter for the Quan
filter(`Molecule` == "C11H19Cl5")|> #Filter for one PCA homologue
filter(str_detect(`Replicate Name`, "11_57_", negate = TRUE)) |> #remove all the other standards 
ggplot(aes(x = `Analyte Concentration`, y = Area)) + #Plot the scater plot
  geom_point() +
  geom_smooth(method = "lm", # uses the linear regression model
              se = FALSE, # this will remove the confidence intervals
              colour = "orange",
              size = 2) +
  theme_classic() +
  ylab("Area")



##########################3########Try to generate a loop for the calibration curve, so I don't need to write the homologue and the standards for every calibration curve###########################################################



```


```{r}
# Create an empty character vector
sample_PFOS_info <- character()

# iteratively fill the empty vector using a for loop and paste text with different cells at the i:th position of each selected column
for (i in 1:length(PFAS_insects$ID)) {
  sample_PFOS_info[i] <- paste("This sample: ", 
              PFAS_insects$ID[i], 
              " has PFOS concentration of", 
              round(PFAS_insects$PFOS[i],2 )
```





```{r}
PFOS_water <- as.numeric()
PFOS_sediment <- as.numeric()
PFOS_earthworms <- as.numeric()
PFOS_emerg_aq_ins <- as.numeric()
PFOS_aq_inslarv <- as.numeric()
PFOS_terr_invcons <- as.numeric()

for (i in 1:length(PFAS_insects$Group)){

if(PFAS_insects$Group[i] == "Water"){
  PFOS_water[i] <- PFAS_insects$PFOS[i]
} else if (PFAS_insects$Group[i] == "Sediment") {
  PFOS_sediment[i] <- PFAS_insects$PFOS[i]
} else if (PFAS_insects$Group[i] == "Earthworms") {
  PFOS_earthworms[i] <- PFAS_insects$PFOS[i]
} else if (PFAS_insects$Group[i] == "Emergent aquatic insects") {
  PFOS_emerg_aq_ins[i] <- PFAS_insects$PFOS[i]
} else if (PFAS_insects$Group[i] == "Aquatic insect larvae") {
  PFOS_aq_inslarv[i] <- PFAS_insects$PFOS[i]
} else if (PFAS_insects$Group[i] == "Terrestrial invertebrate consumers") {
  PFOS_terr_invcons[i] <- PFAS_insects$PFOS[i]
}
}
```





















```{r}
#Response factor of each homologue per 1 ng/ÂµL

#For having the same display as in the Excel sheet we first need to transpose our data frame:

t_CorrectedArea <- t(CorrectedArea)
minC9Cl3<- min(t_CorrectedArea["C9H17Cl3", c('V8', 'V9', 'V10', 'V11')])
minC9Cl3 
###########ERROR: it does not find the column names

#Maybe I can fo it without transposing?

minC9Cl3<- min(CorrectedArea[c('9_48_1', '9_48_2', '9_48_3', '9_48_4'), "C9H17Cl3"]) #min for C9H17Cl3 in the standard
minC9Cl3

maxC9Cl3<- max(CorrectedArea[c('9_48_1', '9_48_2', '9_48_3', '9_48_4'), "C9H17Cl3"]) #max for C9H17Cl3 in the standard
maxC9Cl3

####################ERROR: gives NA as the results 

#x and y represent your independent and dependent variables, respectively.
x<- minC9Cl3
y<- maxC9Cl3
# Fit linear regression model
lm_model <- lm(y ~ x) #lm(y ~ x) fits a linear regression model of y on x.

# Extract the slope coefficient
slope <- round(coef(lm_model)[2], digits = 0) #coef(lm_model) retrieves the coefficients of the fitted model, and [2] selects the second coefficient, which corresponds to the slope.



class(CorrectedArea$C9H17Cl3) #Checking if the values are defined as numeric: yes they are :(

filtered_data <- CorrectedArea[complete.cases(CorrectedArea[c('9_48_1', '9_48_2', '9_48_3', '9_48_4'), "C9H17Cl3"]), ]



Min<- min(GC_qToF_CPsFoodResultsB$IS)
#=ROUND(SLOPE(INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MAX(N4:U4);N4:U4;0));TRUE);INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MAX(N4:U4);N4:U4;0));TRUE));0)
############Note: N4:U4 are the values of the corrected peak are of the standards


#The result from the previous row to this one
#=IF(ISERROR(W4);0;W4)
```
