---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Project

**The main objective of this project is to automatize the workflow of the data treatment for the quantification of Polychlorianted alkanes (PCAs).**

## Correct the instrumental with the internal standard (IS):

```{r}
#Load the libraries
library(dplyr)
library(tidyr)

#Clean the environment
rm(list = ls()) 

#Wide the data so each sample is in one row
GC_qToF_CPsFoodResults3 <- GC_qToF_CPsFoodResults |>  
  filter(Quantitative == "YES") |> 
  pivot_wider(id_cols = `Replicate Name`,
              names_from = Molecule, # name of the new column
              values_from = Area #name of the values for the new columns
             ) #data type       

#Make the data in the data frame numeric
pattern <- "^C\\d+" # This pattern matches column names starting with "C" followed by numbers
GC_qToF_CPsFoodResults3 <- mutate_at(GC_qToF_CPsFoodResults3, vars(matches(pattern)), as.numeric) # Apply as.numeric() to columns matching the pattern
GC_qToF_CPsFoodResults3$IS = as.numeric(GC_qToF_CPsFoodResults3$IS)# Define the IS as numeric 

#Divide the area of the homologues by the IS
CorrectedArea <- mutate_at(GC_qToF_CPsFoodResults3, vars(matches(pattern)), 
                           ~ . / GC_qToF_CPsFoodResults3$IS) #It will now do it for all the columns that have the pattern (start the name with "C")

```

## Calculate the recovery

```{r}
# Define the RS as numeric
GC_qToF_CPsFoodResults3$RS = as.numeric(GC_qToF_CPsFoodResults3$RS) 

#Dividing the IS by RS
Recovery <- mutate(GC_qToF_CPsFoodResults3, GC_qToF_CPsFoodResults3$IS / GC_qToF_CPsFoodResults3$RS) 

Recovery[Recovery$column_name == some_condition, "column_name"]

STD <- average(Recovery$v)
#The recovery in %
RecoveryPercentage <- mutate_at(Recovery, vars(matches(pattern)), 
                           ~ . *100) 
```

```{r}
Recovery <- mutate(GC_qToF_CPsFoodResults3, GC_qToF_CPsFoodResults3$IS / GC_qToF_CPsFoodResults3$RS)
```


## Prepare the single chain standards

```{r}
#Response factor of each homologue per 1 ng/ÂµL

#For having the same display as in the Excel sheet we first need to transpose our data frame:

t_CorrectedArea <- t(CorrectedArea)
minC9Cl3<- min(t_CorrectedArea["C9H17Cl3", c('V8', 'V9', 'V10', 'V11')])
minC9Cl3 
###########ERROR: it does not find the column names

#Maybe I can fo it without transposing?

minC9Cl3<- min(CorrectedArea[c('9_48_1', '9_48_2', '9_48_3', '9_48_4'), "C9H17Cl3"]) #min for C9H17Cl3 in the standard
minC9Cl3

maxC9Cl3<- max(CorrectedArea[c('9_48_1', '9_48_2', '9_48_3', '9_48_4'), "C9H17Cl3"]) #max for C9H17Cl3 in the standard
maxC9Cl3

####################ERROR: gives NA as the results 

class(CorrectedArea$C9H17Cl3) #Checking if the values are defined as numeric: yes they are :(

filtered_data <- CorrectedArea[complete.cases(CorrectedArea[c('9_48_1', '9_48_2', '9_48_3', '9_48_4'), "C9H17Cl3"]), ]

class(CorrectedArea$C9H17Cl3)

Min<- min(GC_qToF_CPsFoodResults3$IS)
#=ROUND(SLOPE(INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MAX(N4:U4);N4:U4;0));TRUE);INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MAX(N4:U4);N4:U4;0));TRUE));0)
############Note: N4:U4 are the values of the corrected peak are of the standards


#The result from the previous row to this one
#=IF(ISERROR(W4);0;W4)
```

