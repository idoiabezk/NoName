[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R course book",
    "section": "",
    "text": "Index\nThe different sections in the book include:\n\nIntroduction\nChapter 1: Getting familiar with R programming\nChapter 2: Hands-on R programming\nChapter 3: Working flows on R programming\nChapter 4: Data transformation\nChapter 5: Data tidying\nChapter 6: Exercise 1\nChapter 7: Project"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This book compiles the information acquired at the PhD course on R for environmental chemistry data analysis. The aim of this course is to learn how use use R studio and be able to treat and visualize environmental data.\nThe first chapters of this book includes the basic knowledge needed to understand how to program in R studio. In the next sections how to plot the data is compiled, for instance, how to use Tidyverse and how to create interactive plots are described. In the next part of this book how to perform statistic test in R studio will be discussed, and finally, how to interact with ChatGPT is included."
  },
  {
    "objectID": "Chapter1.html#basic-understanding",
    "href": "Chapter1.html#basic-understanding",
    "title": "2  Getting familiar with R programming",
    "section": "2.1 Basic understanding",
    "text": "2.1 Basic understanding\nBefore starting with Rstudio functioning, it is essential to briefly summarize the terminology and different elements used in programming.\n\n2.1.1 Terminology\n\nCommand: The command refers to a specific instruction or operation written in the R programming language that users enter into the console or the script editor. In other words, the command is the code that is written to perform various tasks.\nFunction: A function is a block of organized, reusable code designed to perform a specific task. Functions in R are used to encapsulate a set of operations or calculations that can be applied to input data, producing an output. They can be built-in functions provided by R or user-defined functions created by the programmer.\nArgument: An argument is a value passed to a function to customize its behavior or provide input data. Functions in R can have zero or more arguments, which are specified within parentheses when the function is called. Arguments can be variables, constants, or expressions, and they influence the outcome of the function’s execution.\nScript: the script refers to a file containing a series of R commands and functions written in the R programming language. Scripts are used to organize and execute multiple commands sequentially to achieve specific tasks, such as data analysis, visualization, or modeling.\n\n\n\n2.1.2 R studio elements\n\nConsole: the console is the interactive environment where users can directly enter and execute R commands. It provides immediate feedback, displaying the output of commands, errors, warnings, and messages generated during code execution. It is important to remark that the data displayed in the console is not saved.\nScript Editor: The script editor is where you write, edit, and save R scripts. Scripts contain a series of R commands and functions organized to perform specific tasks.\nEnvironment Pane: this pane displays information about the current R environment, including data objects, functions, and variables that are currently loaded into memory.\nFile Pane: the file pane allows you to navigate your file system, view files, and manage your R projects. You can also create new files, folders, and scripts from this pane.\nPlots Pane: when you create visualizations or plots in R, they are displayed in the plots pane. This pane allows you to view and interact with your plots.\nPackages Pane: R packages are collections of functions, data sets, and documentation that extend the capabilities of R. The packages pane allows you to manage and install packages from CRAN (Comprehensive R Archive Network) and other sources.\nHelp Pane: this pane provides access to R documentation and help files. You can search for functions, packages, and topics to find relevant documentation and examples.\nViewer Pane: the viewer pane displays web-based content generated by R packages or Shiny applications.\nGit Pane: if you are using version control with Git, the Git pane allows you to manage your Git repositories, commit changes, and view version history.\nToolbar: the toolbar provides quick access to commonly used actions and commands, such as saving files, running code, and debugging."
  },
  {
    "objectID": "Chapter1.html#basic-operating",
    "href": "Chapter1.html#basic-operating",
    "title": "2  Getting familiar with R programming",
    "section": "2.2 Basic operating",
    "text": "2.2 Basic operating\n\n2.2.1 Ins and outs\nIn Rstudio there are two ways of running a command, in other words telling the system to do a task: we can press “ctrl” “Enter”, or we can click on the “Run” icon in the tool bar. We can also cancel a command by pressing “ctrl” “c”.\nRstudio will take everything that we write in the Script Editor or console as a command, and if we want to add a comment in our command we should write “#” before, R will understand that what comes after is not a command. When we command something in the console, the results appear with a number in brackets, for example:\n\n1+1 #Here we are asking R to calculate the sum of 1 and 1\n\n[1] 2\n\n\nAs can be seen in the example above, when we command “1+1” we get the result is “2”. However, there is “[1]” before it. The number in brackets enumerates the values from the results, in this case, “2” is the first value from our results. This example also shows that the hashtag allows us to include comments in our script which will help to understand it better.\nRStudio works best with vectorized data. A vector is a basic data structure that represents an ordered collection of elements of the same data type, and it can for example be a one-dimension set of numbers, such as the one bellow:\n\n1:6\n\n[1] 1 2 3 4 5 6\n\n\nIn this example, we have used the operator “:” which gives as a result a group of numbers between 1 and 6. This group of number is what we call a vector.\nIf we would like to reuse this vector, then we would need to first save them. For this, Rstudio allows us to generate an object. In the context of RStudio, an object refers to a data structure that holds a value or values. We need to be careful when naming objects, if they start with a number or a special symbol Rstudio will not be able to run it. Also, we need to keep in mind that Rstudio is affected by the capital letters and “House” and “house” are two different things for R. Moreover, we can’t forget that R overwrites the object names, we can always which names have been already assigned by running 1s()\nFollowing up with the previous example we can create an object for the vector, so later on, we will be able to use it in other operations.\n\na &lt;- 1:6 #we generate the object named \"a\" and it will contain the result of the operation \"1:6\"\na\n\n[1] 1 2 3 4 5 6\n\n\nNow we will have an object named “a” in our environment which contains the vector (1, 2, 3, 4, 5, 6), and if we want to operate with it we just need to write the name of the object (a) in our command, such as:\n\na+2\n\n[1] 3 4 5 6 7 8\n\n\nAs it can be seen in the example, when we sum 2 to the vector named “a”, R does element-wise execution, in other words, it sums 2 to every element in our vector, in this example: (1+2, 2+2, 3+2, 4+2, 5+2, 6+2). R will also element-wise execution when operating with two vectors, and if these do not have the same lengths, R will repeat the short one as long as the long one, this is known as vector recycling.\nHowever, if we would like to do a traditional matrix operation, we should include “%” before and after our operation, for example:\n\na%*%a\n\n     [,1]\n[1,]   91\n\n\n\n\n2.2.2 Functions\nA function is the task that we ask R to realize, it contains the operations or calculations that can be applied to input data. Some of examples of functions can be the ones bellow:\n\nRound() it is used to round numerical values to a specified number of decimal places, for example:\n\n\nround(2,1)\n\n[1] 2\n\n\n\nmean() it is used to calculate the arithmetic mean (average) of a numeric vector or values, for example:\n\n\nmean(a)\n\n[1] 3.5\n\n\n\nsum() it is used to calculate the sum of numeric values in a vector or a data frame, for example:\n\n\nsum(a)\n\n[1] 21\n\n\n\nsample() it is used to generate random samples from a specified set of elements, for example:\n\n\nsample(a)\n\n[1] 1 6 5 4 3 2\n\n\n\nc() it is used to combine values into a single vector or list, for example:\n\n\nc(1, 5, 12, 20)\n\n[1]  1  5 12 20\n\n\nThere are many functions that we can use in Rstudio, and all of them are composed by three main parts: a name, a body of the code and a set of arguments, for instance the one below:\n\nana &lt;- function(){\n  b &lt;- c(1, 2, 3, 4, 5, 6)\n  b &lt;- sample(b, size = 2)\n  sum(b)\n}\nana ()\n\n[1] 7\n\n\nIn this example the name of the function is “ana”, the body is everything that come in between the ““{}” and the arguments in this case are values that input for the functions, such as in the case of “sample()” the arguments are “b” (the data set that we are imputing) and “size =2” (how many values do we want that R gets out of this data set). Note that if we don’t know which are the arguments for a function we can always use “args(the name of the function)2 in the console and it will give us a description how to imput the arguments. Now that we have name the function we can just write the name instead of rewriting the entire function body, as it can be seen in the example”ana()” gives the output of the entire function.\nWe also put an argument in the function, such as “ana(b2)”, now the function “ana” will only work when we input what the argument “b2” is, for instance:\n\nana &lt;- function(b2){\n  b3 &lt;- sample(b2, size = 2)\n  sum(b3)\n}\n#ana() gives us error because we have not defined what \"b2\" is\n\n\nana &lt;- function(b2){\n  b3 &lt;- sample(b2, size = 2)\n  sum(b3)\n}\nana (b2 = 1:4) #Here we define what \"b2\" is and Rstudio can run the function \"ana()\" for it\n\n[1] 6\n\n\n?apply #Note for myself: look it up ### Packages\nWe can build up our own functions, but can also use these that other people have already coded. For this, we have to install packages and load their libraries. A package is a collection of R functions, data sets, and compiled code in a well-defined format, while a library refers to a directory where installed packages are stored on your computer. When you install a package, its files are copied to a specific location on your system. This location is referred to as the library. So, depending on our aim we will install different packages and load their libraries. Note that we only need to install a package once, but we need to load its library every R session we want to use it.\nFor instance, “qplot” is a function used for making quick plots in R, but it is part of the package”ggplot2”, so for being able to use it, we must install the package and load the library:\n\n#install.packages(\"ggplot2\") to install the package (I don't want to run because I alredy have it)\nlibrary(ggplot2) #load the function\nx &lt;- c(1,1,2,2,2,3) #define the data\nqplot(x, binwidth = 1) #the function and the arguments we want to use\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\nEach package uses different functions, and it might be confusing to know how they operate and how to input the augments. R comes with a “Help” option, if we write in the console “?packagename”, where packagename refers to the actual name of the package, we will will the information about how to use it. Note that for being able to get the help, the package need to be installed before."
  },
  {
    "objectID": "Chapter2.html#r-objects",
    "href": "Chapter2.html#r-objects",
    "title": "3  Hands-on R programming",
    "section": "3.1 R objects",
    "text": "3.1 R objects\nWhen talk about R objects we are referring to the data set. The different ways of defining our data set are described below.\n\n3.1.1 Vectors\nVectors can only save one-dimension data and only one type of data. We have different types of vectors, such as, numerical, text and logical, look at the examples below:\n\nv1 &lt;- c(1,2,3,4,5,6) #numerical\nv1\n\n[1] 1 2 3 4 5 6\n\n\n\nv2 &lt;- c(\"I\", \"am\", \"Idoia\") #text\nv2\n\n[1] \"I\"     \"am\"    \"Idoia\"\n\n\n\nv3 &lt;- c(TRUE, FALSE, TRUE) #logical\nv3\n\n[1]  TRUE FALSE  TRUE\n\n\nNote that R will be able to do mathematical operations with vectors that contain numerical values, but not with the ones that have text. If we want to check is an object is a vector or not, we can write “is.vector” and if we want to know the length of a vector “length” will give it:\n\nis.vector(v1)\n\n[1] TRUE\n\n\n\nlength(v1)\n\n[1] 6\n\n\nKeep in mind that a vector can also contain just one value.\n\n3.1.1.1 Attributes\nAttributes are pieces of information that we can attach to a vector, we can look at them by “attributes(vector)”, where vector should be substituted by the name of the vector that we want to check. For example, if we want to attributed names to the values of the vector “v1” we can write an attribute to them:\n\nnames(v1)&lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\") #names if the attribute that we want to add and in brackets the vector that we want to add them to\nattributes(v1) #will show us the attributes of the vector \"v1\"\n\n$names\n[1] \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\"  \n\n\nR will display the attributed is we just look at the vector too:\n\nv1\n\n  one   two three  four  five   six \n    1     2     3     4     5     6 \n\n\nWe can also remove the attributes from a vector:\n\nnames(v1) &lt;- NULL\n\nIf now look at the vector, the names of the values won’t be there anymore:\n\nv1\n\n[1] 1 2 3 4 5 6\n\n\n\n\n\n3.1.2 Matrices\nMatrices are used for storing values in two dimensions. We can for example transform a vector into a matrix by attributing two dimensions:\n\ndim(v1) &lt;- c(2,3)\nv1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nR will fill in the matrix column by column by default, if we want to fill it by row we have to set up “byrow = TRUE”.\n\nm1 &lt;- matrix(v1, nrow =2) #it will fill it by column\nm1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n\nm2 &lt;- matrix(v1, nrow =2, byrow = TRUE) #it will fill it by row\nm2\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n\n\n\n3.1.3 Lists\nLists are data structures that can contain elements of different types (such as vectors, matrices, other lists, functions, etc.) in a single object. Note that the elements are not grouped together, and so, it allows us to have vectors of different lengths and characteristics, an example:\n\nl1 &lt;- list(10:30, \"Idoia\", list(TRUE, FALSE))\nl1\n\n[[1]]\n [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n\n[[2]]\n[1] \"Idoia\"\n\n[[3]]\n[[3]][[1]]\n[1] TRUE\n\n[[3]][[2]]\n[1] FALSE\n\n\n\n\n3.1.4 Data frames\nData frames are the two dimensional version of a list, they group vectors together into a two-dimensional table, where each vector becomes a column in the table. Therefore, we must have the same type of data in each column, but we can have different types of data between several columns, such as:\n\ndf1 &lt;- data.frame(People = c(\"Victoria\", \"Thanh\", \"Idoia\"),  \n  Position = c(\"Student\", \"Boss\", \"Student\"), YearsWorking = c(0.17, 25, 2.17))\ndf1\n\n    People Position YearsWorking\n1 Victoria  Student         0.17\n2    Thanh     Boss        25.00\n3    Idoia  Student         2.17\n\n\nAs it can be seen in the previous example, a data frame allows us to give names to the different vectors that we have, in this case “People”, “Position” and “YearsWorking”.\n\n\n3.1.5 Arrays\nArrays are used for storing values of the same data type in multiple dimensions, for example to sort values into a 3 dimensional cube, like:\n\nar1&lt;- array(c(11:14,21:24,31:34), dim = c(2,2,3))\nar1\n\n, , 1\n\n     [,1] [,2]\n[1,]   11   13\n[2,]   12   14\n\n, , 2\n\n     [,1] [,2]\n[1,]   21   23\n[2,]   22   24\n\n, , 3\n\n     [,1] [,2]\n[1,]   31   33\n[2,]   32   34\n\n\n\n\n3.1.6 Playing with the objects\n\n3.1.6.1 Class\nClass refers to the type or category of an object, it will tell us what type if structure do we have:\n\nclass(df1)\n\n[1] \"data.frame\"\n\n\nKnowing the class of the data might be very useful in some occasions, such as with the dates the dates. In this case we have is a numerical vector, it is displayed like a text. This is because the class of the data represent the dates ans times are “POSIXct” AND “POSIXt”, for example:\n\nnow &lt;- Sys.time()\nnow\n\n[1] \"2024-03-25 09:28:52 CET\"\n\ntypeof(now)\n\n[1] \"double\"\n\n\nDouble refers to the numerical vectors\n\nclass(now)\n\n[1] \"POSIXct\" \"POSIXt\" \n\n\nChanging the class of a vector might be very useful when we want to categorize our values too. Is we have for instance a vector that contains “text”, but we want to sort it into categories, we can use the function “factor()” that will allow us to change the class of our vector from text to factors, for instance:\n\nv4&lt;- c(\"male\", \"female\", \"male\")\nclass(v4)\n\n[1] \"character\"\n\n\n\ngender &lt;- factor(v4)\nattributes(gender)\n\n$levels\n[1] \"female\" \"male\"  \n\n$class\n[1] \"factor\"\n\n\nNow we have our vector into categories:\n\nunclass(gender) #it will display our data into the categories 1 and 2\n\n[1] 2 1 2\nattr(,\"levels\")\n[1] \"female\" \"male\"  \n\n\n\n\n3.1.6.2 Coercion\nIn R, coercion refers to the process of converting an object from one data type or class to another.\nR always follows the same rules when it coerces data types:\n\nIf a character string is present in a vector, R will convert everything else in the vector to character strings.\nIf a vector only contains logicals and numbers, R will convert the logicals to numbers (every TRUE becomes a 1, and every FALSE becomes a 0)."
  },
  {
    "objectID": "Chapter2.html#notation",
    "href": "Chapter2.html#notation",
    "title": "3  Hands-on R programming",
    "section": "3.2 Notation",
    "text": "3.2 Notation\nDepending on the notation that we use in our commands R will realize one task or another, therefore it is very important to be cautious when writing the code.\n\n3.2.1 Extracting values from a data frame\nIf we want to extract on specific value from a data frame, we should use the [] instead of (), for example:\n\ndf1[2,3] #[a,b] where a=row and b=column\n\n[1] 25\n\n\nWe also use it for extracting more than one value, such as:\n\ndf1[2,c(2,3)]\n\n  Position YearsWorking\n2     Boss           25\n\n\nWe can use to create a new data frame out of the previous one:\n\ndf2&lt;- df1[1:2,1:2]\ndf2\n\n    People Position\n1 Victoria  Student\n2    Thanh     Boss\n\n\nNote that if we extract only one column, we will get a vector instead.\nWe can also apply this principle in the opposite direction, in other words, we can extract everything but a value for instance:\n\ndf1[1:3,-2]\n\n    People YearsWorking\n1 Victoria         0.17\n2    Thanh        25.00\n3    Idoia         2.17\n\n\nWe could leave a blank space, this will allow us to extract everything in the dimension:\n\ndf1[1,]#it will extract everything in the first row\n\n    People Position YearsWorking\n1 Victoria  Student         0.17\n\n\nNote that we can also use logical vectors and extract elements by name.\n\n\n3.2.2 Extracting columns from a data frame\nIf we want to extract a column from a data frame we can also use the”$” sign, for example:\n\ndf1$People #from the data frame \"df1\", the column \"People\"\n\n[1] \"Victoria\" \"Thanh\"    \"Idoia\"   \n\n\nNote that R will return the values as a vector.\nAnother option for extracting a column is to use the double “[[]]”, it will act the same way as the “$” sign."
  },
  {
    "objectID": "Chapter2.html#modifying-values",
    "href": "Chapter2.html#modifying-values",
    "title": "3  Hands-on R programming",
    "section": "3.3 Modifying values",
    "text": "3.3 Modifying values\n\n3.3.1 Changing values\nWe can change the values from our data, for instance we can change one of the values of a numeric vector by renaming it:\n\nv5&lt;- c(0,0,0,0,0,0)\nv5[1]&lt;-1000 #we select the first value of the vector \"v5\" and we replace it by \"1000\"\nv5\n\n[1] 1000    0    0    0    0    0\n\n\nWe can apply the same principle to replace multiple variables:\n\nv5[c(1,2,3)]&lt;-c(1,1,1)\nv5\n\n[1] 1 1 1 0 0 0\n\n\nAnother option could be to add more variables:\n\nv5[7]&lt;-0 #we select the 7th value of the vector v5 which is empty and replace it for a 0\nv5\n\n[1] 1 1 1 0 0 0 0\n\n\nThis principle can also be applied to remove some values as well:\n\ndf1$Position&lt;-NULL #We select the column \"Position\" from the data frame \"df1\" and delete it\ndf1\n\n    People YearsWorking\n1 Victoria         0.17\n2    Thanh        25.00\n3    Idoia         2.17\n\n\n\n\n3.3.2 Logical subsetting\nLogical tests refer to evaluating an expression to determine whether it is true or false, here are some of the most used logical operators:\n\n“&gt;”: is it greater than?\n“&gt;=: is it greater or equal than?\n“&lt;”: is it less than?\n“&lt;=: is it less or equal than?\n“==: is it equal to?\n“!=: is not equal to?\n“%in%: is it in the group?\n\nSome examples:\n\n3&lt;2 #is 3 less than 2?\n\n[1] FALSE\n\n\n\n3 %in% c(1,2,3) #is 3 in the vector that is in the right?\n\n[1] TRUE\n\n\n\nc(1,2,3)%in%c(3,4,5) #%in% doesn't do element-wise execution, it will provide is the values of the vector to the left are any of the values of the vector to the right\n\n[1] FALSE FALSE  TRUE\n\n\n\n\n3.3.3 Boolean operators\nThe boolean operators “&” and “|” collapse the results of multiple logical tests into a sinlge TRUE or FALSE, for example:\n\ncond1&lt;-2&lt;3\ncond2&lt;-3&lt;3\ncond1&cond2 #are \"cond1\" and \"cond2\" true?\n\n[1] FALSE\n\n\nHere are some of the most used boolean operators:\n\n“&”: are both true?\n“|”: is of them true?\n“xor”: is exactly one of them true?\n“!”: is it false? (might be uselful for flipping a condition, for example with !is.na())\n“any”: are any of these conditions true?\n“all”: are all of them true?\n\n\n\n3.3.4 Missing information\nWhen we miss some information R will display “NA” which means “Not Available” For removing the “NA2s we can use: na.rm = TRUE If what we want does not have the”na.rm” we could use: vector[!is.na()], so it will take everything that is not NA."
  },
  {
    "objectID": "Chapter2.html#environments",
    "href": "Chapter2.html#environments",
    "title": "3  Hands-on R programming",
    "section": "3.4 Environments",
    "text": "3.4 Environments\nEnvironments refer to the spaces where objects (such as variables, functions, etc.) are created and stored during an R session."
  },
  {
    "objectID": "Chapter3.html#useful-operations",
    "href": "Chapter3.html#useful-operations",
    "title": "4  Working flows on R programming",
    "section": "4.1 Useful operations",
    "text": "4.1 Useful operations\n\n4.1.1 “If” and “Else” statements\n\nThe “if” statement allows us to tell R to a task only when a condition in “TRUE”. For example:\n\n\nnum&lt;-2#define what why want to study\n\nif(num&gt;0){ #if our num is bigger than zero do...\n  num&lt;-num-1 #...num-1\n}\nnum\n\n[1] 1\n\n\n\nThe “else” statement allows us to include a second statement, in other words,”if this is not TRUE do something else”, for example:\n\n\nnum&lt;-2#define what why want to study\n\nif(num&lt;0){ #if our num is smaller than zero do...\n  num&lt;-num-1 #...num-1\n} else { #in the case that num is NOT smaller than zero do...\n  num&lt;-num+1 #... do num + 1\n}\nnum\n\n[1] 3\n\n\nFor the cases in the “if” statement is TRUE, R will ignore the “else” one; “else” will only be applied when the “if” statement is FALSE.\n\n\n4.1.2 Others\n\nFor isolating the decimal we can use “trunc()”:\n\n\nt&lt;-3.14\ntrunc(t)\n\n[1] 3\n\n\n\nThe double “&&” and “||” behave like “&” and “|”, but can sometimes be more efficient: the double operator will not evaluate the second test if the first makes the result clear.\nLookup tables are used for creating a vector between two variables, for example:\n\n\nWorkingYears&lt;-c(\"Victoria\"=0.17, \"Thanh\"=25, \"Idoia\"=2.17)\nWorkingYears[\"Thanh\"]#it will allow us to look at the variable \"Thanh\" and the values\n\nThanh \n   25 \n\n\nWe could also write:\n\nunname(WorkingYears[\"Thanh\"]) #we can look at the value of the variable \"Thanh\"\n\n[1] 25\n\n\n\n“expand.grid”: for a quick write out of every combination of elements in n vectors, and further determine the probability of each combination, for example:\n\n\na&lt;- 1:6\nA&lt;-expand.grid(a,a)\nA\n\n   Var1 Var2\n1     1    1\n2     2    1\n3     3    1\n4     4    1\n5     5    1\n6     6    1\n7     1    2\n8     2    2\n9     3    2\n10    4    2\n11    5    2\n12    6    2\n13    1    3\n14    2    3\n15    3    3\n16    4    3\n17    5    3\n18    6    3\n19    1    4\n20    2    4\n21    3    4\n22    4    4\n23    5    4\n24    6    4\n25    1    5\n26    2    5\n27    3    5\n28    4    5\n29    5    5\n30    6    5\n31    1    6\n32    2    6\n33    3    6\n34    4    6\n35    5    6\n36    6    6"
  },
  {
    "objectID": "Chapter3.html#s3-system",
    "href": "Chapter3.html#s3-system",
    "title": "4  Working flows on R programming",
    "section": "4.2 S3 system",
    "text": "4.2 S3 system\nDepending on the vector class (attributes) R will display it differently, for example:\n\nnum2&lt;-10000\nprint(num2)\n\n[1] 10000\n\n\nBut if we do:\n\nclass(num2)&lt;- c(\"POSIXct\",\"POSIXt\")\nprint(num2)\n\n[1] \"1970-01-01 03:46:40 CET\"\n\n\nDepending on the class R reads the same value as a number or as a date. Every time we code something, R has to examine the type of our input, and pass to the class needed so the output can be generated. This is done by “UseMethod”, this will for instance examine an imputed object in as”POSIXct” class, and pass it to “print.POSIXct” so R can print the result, where #print# is the function and “POSIXct” the class. This is always happening in R and if we want to see every method written for a class we have to use “method(class=”factor”)“."
  },
  {
    "objectID": "Chapter3.html#the-loops",
    "href": "Chapter3.html#the-loops",
    "title": "4  Working flows on R programming",
    "section": "4.3 The loops",
    "text": "4.3 The loops\nA loop is a programming construct used to repeatedly execute a block of code until a certain condition is met. There are different types of loops in R, including for loops, while loops, and repeat loops.\n\n“For” tells R to do “this” for every value of “that”. It is very useful for connecting a piece of a code with each element in a set. Note that R runs a loop in which ever environment, so if the loop uses objects that already exist in another environment, R will overwrite them.\n\n\nfor (value in c(\"I\", \"am\", \"Idoia\")) {\n  print(\"IBE\") #it will print for every value in the vector\n}\n\n[1] \"IBE\"\n[1] \"IBE\"\n[1] \"IBE\"\n\n\n\n“While” reruns a chunk while a certain condition remains TRUE, for example:\n\n\nnum&lt;--3\nwhile(num&lt;0){\n  num&lt;-num+2\n}\nnum\n\n[1] 1\n\n\nNote that is the condition, in the case that “num” is smaller than 0, evaluates FALSE the “while” loop will stop.\n\n“Repeat” allows us to repeat a chunk of code until we tell R to stop by hitting Escape or by clicking on the stop-sign icon at the top of the RStudio console pane. For example:\n\n\nplays_till_broke &lt;- function(start_with) {\n  cash &lt;- start_with\n  n &lt;- 0\n  repeat { #we tell to do it again until...\n    cash &lt;- cash - 1 \n    n &lt;- n + 1\n    if (cash &lt;= 0) {\n      break #...we tell to stop\n    }\n  }\n  n\n}\nplays_till_broke(100)\n\n[1] 100"
  },
  {
    "objectID": "Chapter3.html#the-speed",
    "href": "Chapter3.html#the-speed",
    "title": "4  Working flows on R programming",
    "section": "4.4 The speed",
    "text": "4.4 The speed\nRstudio operates the fastest with vectorial data, this means that it will do the quickest the logical tests, subsetting, and element-wise execution.\nFor writing a vectorial code: 1) use vectorized codes (“&lt;-”) 2) use logical subsetting to handle parallel cases.\nNote that the loop “for” operates very slow, and if we do “abs_loop” R uses the “for” loop to manipulate each element of the vector one at the time. Therefore, it is better to use the vectorized version of it: “abs_set”.\nRemember that R will do the function in the brackets before and then the one out."
  },
  {
    "objectID": "Chapter4.html#the-pipe",
    "href": "Chapter4.html#the-pipe",
    "title": "5  Data transformation",
    "section": "5.1 The pipe ” |> ”",
    "text": "5.1 The pipe ” |&gt; ”\nBefore getting into the different functions of “tidyverse”, we need to describe the “pipe”. The pipes take what is on the left and pass it along to the function on the right. For example, it is the same to write ” x |&gt; f(y)” and “f(x,y)”. The pipe is very useful to combine different functions and to avoid creating new objects.\nThe shortcut to add the pipe is “ctrl + shift + M”."
  },
  {
    "objectID": "Chapter4.html#dplyr-function-groups",
    "href": "Chapter4.html#dplyr-function-groups",
    "title": "5  Data transformation",
    "section": "5.2 “dplyr” function groups",
    "text": "5.2 “dplyr” function groups\nAll the “dplyr” functions are organized into four groups based on what they operate on rows, columns, groups, and tables. All these functions will be used in examples in the next exercise.\n\n5.2.1 Rows:\n\n5.2.1.1 Filter ():\nChanges in which rows are present without changing the order of the rows. It allows us to keep rows based on the values of the columns.\nNote that “=” does not mean equal to, if we want to input equal to we need to write “==”.\n\n\n5.2.1.2 Arrange ():\nChanges the order of the rows without changing which ones are present. Note that it does it based on the values of the columns. When inputting more than one column, the function will operate based on the order in which we write them.\nWe can use “desc()” on a column inside of “arrange ()” to reorder the data frame based on the values in that column from the biggest to the smallest.\n\n\n5.2.1.3 Distinct ():\nFinds rows with unique values and can also modify the columns.\nIf we want to keep other columns when filtering unique rows, we can use “keep_all = TRUE”. If we use “sort = TRUE” will arrange them in a descending order.\n\n\n\n5.2.2 Columns:\n\n5.2.2.1 Mutate ():\nCreates more columns that are derived from the original ones. It will add the new variables at the right of the ones that we already had, if we want them at the left we need to write: “.before”, and if we want them before and after: “.after”. Also, we need to include “.keep” for the ones that we want to keep.\n\n\n5.2.2.2 Select ():\nChanges in which columns are present, act like “zooming” in a variable. We have different ways how we can select the columns: - By the name of the column - All the columns between 2 columns: “nameColumnA:nameColumnB” - All the columns except some: “!nameColumnA:nameColumnB” - The columns that the same type such as numeric, or characters\n\n\n5.2.2.3 Rename ():\nChange the name of the column. We can easily clean the names of the column by: “janitor::clean_names()”.\n\n\n5.2.2.4 Relocate ():\nChanges the position of the columns.\n\n\n\n5.2.3 Groups:\n\n5.2.3.1 Group_by ():\nTo divide the data set into groups that are mean full for the analysis.\n\n\n5.2.3.2 Summarize ():\nTo calculate a single summary statistics. It reduces the data frame to have a single row for each group. If we want to know the number of rows taken for each group we can use “n()#.\n\n\n5.2.3.3 Slice ():\nThis function allows us to extract specific rows within each group:\n\n“df |&gt; slice_ head (n =1)” Takes the first row of each group\n“df |&gt; slice_ tail (n =1)” Takes the last row of each group\n“df |&gt; slice_ min (x, n =1)” Takes the row the smallest value of x.\n“df |&gt; slice_ max (x, n =1)” Takes the row the biggest value of x.\n“df |&gt; slice_ sample (n =1)” Takes a random row. If we write “n=1” it will give us one row, but if we can more we can write another number; we can also write “prop =0.1” and this will give us the %10 of the rows.\n\n\n\n5.2.3.4 Grouping by multiple variables ():\nCreates groups using more than one variable.\n\n\n5.2.3.5 Ungrouping:\nWe can use “ungroup()” to remove some grouping.\n\n\n5.2.3.6 “.by” ():\n“group_by()” and “ungroup()” are not groing away."
  },
  {
    "objectID": "Chapter5.html#tidy-data",
    "href": "Chapter5.html#tidy-data",
    "title": "6  Data tidying",
    "section": "6.1 Tidy data:",
    "text": "6.1 Tidy data:\nWe say that we have tidy data when: - Each variable is a column, and each column is a variable\n\nEach observation is a row, and each row is an observation\nEach value is a cell, and each cell is a value"
  },
  {
    "objectID": "Chapter5.html#lengthening-data",
    "href": "Chapter5.html#lengthening-data",
    "title": "6  Data tidying",
    "section": "6.2 Lengthening data:",
    "text": "6.2 Lengthening data:\n“pivot_longer()” is a function that helps us to tidy the data. The arguments for this function are:\n\n“cols”: specifies which columns need to be pivoted\n“names_to”: names the variables stored in the column names\n“values_drop_na = TRUE” removes missing values"
  },
  {
    "objectID": "Chapter5.html#widering-data",
    "href": "Chapter5.html#widering-data",
    "title": "6  Data tidying",
    "section": "6.3 Widering data:",
    "text": "6.3 Widering data:\n“pivot_longer()” increases the columns and reduces the rows. It helps when an observation is spread across multiple rows. For using it we need to provide where to take the data from:\n\n“names_from = ajfdkl”\n“values_from = adkfdofjio”\n“id_cols = iadjoid”"
  },
  {
    "objectID": "Chapter5.html#other-useful-functions",
    "href": "Chapter5.html#other-useful-functions",
    "title": "6  Data tidying",
    "section": "6.4 Other useful functions:",
    "text": "6.4 Other useful functions:\n\n“parse_number()” will extract the first number of a string and ignore the text.\n“names_sep =”_“” will allow us to extract some information from a name and make it a variable."
  },
  {
    "objectID": "Chapter6.html#basic-and-ggaplot2-plots",
    "href": "Chapter6.html#basic-and-ggaplot2-plots",
    "title": "7  Exercise 1: Data plotting and transformations",
    "section": "7.1 Basic and ggaplot2 plots:",
    "text": "7.1 Basic and ggaplot2 plots:\n\n#Load the Excel file:\nlibrary(readxl) #Load the library for inporting the file to R\n\n#Select the file\nStatistics_Kumla_20200408&lt;-read_excel(\"F:/LINKOPING/Credits/Courses/LiU/Data Visualization/R/Statistics_Kumla_20200408.xlsx\")\n\nScatter plot: using plot()\n\n# http://www.sthda.com/english/wiki/scatter-plots-r-base-graphs\n\nplot(x = Statistics_Kumla_20200408$PFBA, y = Statistics_Kumla_20200408$PFOS, main = \"PFBA vs PFOS concentrations\",\n     xlab = \"PFBA concentrations (ng/L)\",\n     ylab = \"PFOS concentrations (ng/L\",\n     pch = 19) # choosing symbol for points in a graph (see ?pch for number/symbol) \n\n\n\n\nScatter plot: ggplot2\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nggplot(\n  data = Statistics_Kumla_20200408,\n  mapping = aes(x = PFBA, y = PFOS)\n) +\n  geom_point()\n\n\n\n\nScatter plot + regression line: using plot()\n\nplot(x = Statistics_Kumla_20200408$PFOA, y = Statistics_Kumla_20200408$PFBA, main = \"PFBA vs PFOS concentrations\",\n     xlab = \"PFOA concentrations (ng/L)\",\n     ylab = \"PFBA concentrations (ng/L\",\n     pch = 19) + # choosing symbol for points in a graph (see ?pch for number/symbol)\n\n# We can add a regression line into the same graph\nabline(lm(Statistics_Kumla_20200408$PFOA ~ Statistics_Kumla_20200408$PFBA, data = Statistics_Kumla_20200408), col = \"orange\", lwd = 3) # lwd is the line width\n\n\n\n\ninteger(0)\n\n\nScatter plot + regression line: using ggplot\n\nggplot(\n  data = Statistics_Kumla_20200408,\n  mapping = aes(x = PFOA, y = PFBA)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = FALSE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n   theme_test()\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nScatter plot + loess fit line: using plot()\n\nplot(x = Statistics_Kumla_20200408$PFOA, y = Statistics_Kumla_20200408$PFBA, main = \"PFBA vs PFOS concentrations\",\n     xlab = \"PFOA concentrations (ng/L)\",\n     ylab = \"PFBA concentrations (ng/L\",\n     pch = 19) + # choosing symbol for points in a graph (see ?pch for number/symbol)\n# as well as a loess fit\nlines(lowess(Statistics_Kumla_20200408$PFBA, Statistics_Kumla_20200408$PFOA), col = \"green\", lwd = 3)\n\n\n\n\ninteger(0)\n\n# to clear the graphics from the Plots pane, use graphics.off() in the script or dev.off() in the console\n\nScatter plot + loess fit line: using ggplot\n\nggplot(\n  data = Statistics_Kumla_20200408,\n  mapping = aes(x = PFOA, y = PFBA)\n) +\n  geom_point() +\n  geom_smooth(method = \"loess\",\n              se = FALSE,\n              colour = \"green\",\n              size = 2) +\n  theme_test()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nBar plots: using barplot()\n\ngroupsPFOS &lt;- Statistics_Kumla_20200408[, c(\"Group\", \"PFOS\")] # subset two variables from the dataframe\ngroupsPFOS$Group &lt;- as.factor(groupsPFOS$Group)\nbarplot(height = Statistics_Kumla_20200408$PFOS)\n\n\n\n\nBar plots: using ggplot\n\nmissing\n\nfunction (x)  .Primitive(\"missing\")\n\n\nBox plots: using boxplot()\n\n# Box plot of one variable\nboxplot(Statistics_Kumla_20200408$PFBS)\n\n\n\n\nBox plots: using ggplot\n\nmissing\n\nfunction (x)  .Primitive(\"missing\")"
  },
  {
    "objectID": "Chapter6.html#more-advanced-plot-using-ggaplot2",
    "href": "Chapter6.html#more-advanced-plot-using-ggaplot2",
    "title": "7  Exercise 1: Data plotting and transformations",
    "section": "7.2 More advanced plot using ggaplot2:",
    "text": "7.2 More advanced plot using ggaplot2:\n\nggplot(\n  data = Statistics_Kumla_20200408,\n  mapping = aes(x = ID, y = PFBA, color = Group)\n) +\n  geom_point()\n\n\n\n\n\nggplot(\n  data = Statistics_Kumla_20200408,\n  mapping = aes(x = ID, y = PFBA, color = Group)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nggplot(\n  data = Statistics_Kumla_20200408,\n  mapping = aes(x = ID, y = PFBA)\n) +\n  geom_point(mapping = aes(color = Group, shape = Group_Family)) +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: The shape palette can deal with a maximum of 6 discrete values because\nmore than 6 becomes difficult to discriminate; you have 24. Consider\nspecifying shapes manually if you must have them.\n\n\nWarning: Removed 52 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nggplot(data = Statistics_Kumla_20200408, mapping = aes(x = PFOA, y = PFBA)) +\n  geom_point(size = 2, colour = \"black\") + # add a scatter plot\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = TRUE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n  geom_smooth(method = \"loess\",\n              se = TRUE,\n              colour = \"green\",\n              size = 2)\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nggplot(data = Statistics_Kumla_20200408, mapping = aes(x = PFOA, y = PFOS)) +\n  geom_point(size = 2, colour = \"black\") + # add a scatter plot\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = FALSE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n  geom_smooth(method = \"loess\",\n              se = FALSE,\n              colour = \"green\",\n              size = 2)\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\nStatistics_Kumla_20200408 |&gt;  select(Year, PFOA) |&gt; filter(Year== 2017)\n\n# A tibble: 70 × 2\n    Year    PFOA\n   &lt;dbl&gt;   &lt;dbl&gt;\n 1  2017 21.7   \n 2  2017  8.38  \n 3  2017  0.219 \n 4  2017 53.9   \n 5  2017 12.0   \n 6  2017  0.218 \n 7  2017  0.683 \n 8  2017  0.0332\n 9  2017  3.54  \n10  2017  2.03  \n# ℹ 60 more rows\n\n\n\nggplot(data = Statistics_Kumla_20200408) +\n  geom_point(mapping = aes(x = PFOA, y = PFBA, size = PFOS), colour = \"black\") \n\n\n\n\n\nggplot(data = Statistics_Kumla_20200408) +\n geom_point(mapping = aes(x = PFOA, y = PFBA, size = PFOS), colour = \"black\") +  \n  scale_size_continuous(\n    name = \"PFOS Description\",\n    breaks = c(10, 50, 100, 500, 1000),  # Adjust the breaks to include more values\n    labels = c(\"10\", \"50\", \"100\", \"500\", \"1000\")  # Adjust labels accordingly\n  )\n\n\n\n\n\nggplot(data = Statistics_Kumla_20200408) +\n geom_point(mapping = aes(x = PFOA, y = PFBA, size = PFOS), colour = \"black\") +\n  scale_size_continuous(\n    name = \"PFOS Description\",\n    breaks = c(10, 50, 100, 500, 1000),  # Adjust the breaks to include more values\n    labels = c(\"10\", \"50\", \"100\", \"500\", \"1000\")  # Adjust labels accordingly\n  ) +\n  geom_smooth(mapping = aes(x = PFOA, y = PFOS), \n              method = \"lm\", \n              se = FALSE, \n              colour = \"orange\",\n              size = 2) +\n  geom_smooth(mapping = aes(x = PFOA, y = PFOS), \n              method = \"loess\",\n              se = FALSE,\n              colour = \"green\",\n              size = 2) +\n  geom_point(mapping = aes(x = PFOA, y = PFBS, # new mapping\n                           size = PFBS), # size of points according to PFBS values\n             colour = \"purple\") + # colour outside of mappings \n  theme_classic() # This theme will remove the background colours and lines\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Chapter6.html#data-transformation-for-ggplot-plotting",
    "href": "Chapter6.html#data-transformation-for-ggplot-plotting",
    "title": "7  Exercise 1: Data plotting and transformations",
    "section": "7.3 Data transformation for ggplot plotting:",
    "text": "7.3 Data transformation for ggplot plotting:\n\nPFAS_insects_long &lt;- Statistics_Kumla_20200408 %&gt;% # shortcut for pipe Ctrl + shift + M\n  pivot_longer(cols = PFBA:PFOA, # select all columns from PFBA to sum_21PFAS\n               names_to = \"somePFAS\", # name of the new column\n               values_to = \"Conc\") %&gt;%  #name of the values from PFBA:sum_21PFAS\n  mutate(somePFAS = as.factor(somePFAS)) #make PFAS column a factor variable\n\n\n#check the PFAS group names\nPFAS_insects_long |&gt; group_by(somePFAS) |&gt; tally() |&gt; view() \n# select PFOS isomers\nPFOS_branched &lt;- c(\"1-PFOS 419/169\", \"3/4/5-PFOS80/98.9\")\n\nPFAS_insects_long |&gt;\n  filter(Group != \"Water\") |&gt; #remove all water samples to only include solid samples\n  filter(str_detect(somePFAS, \"sum_\", negate = TRUE)) |&gt; #remove all sum of PFAS using the argument: negate=TRUE \nggplot(aes(x = somePFAS, y = Conc)) +\n  geom_point() +\n  geom_boxplot() +\n  theme_classic() +\n  ylab(\"Concentration of PFAS (ng/g) in solid samples\")\n\n\n\n\n\nPFAS_insects_long |&gt; mutate(Color = ifelse(Conc &gt; 50, \"orange\", \"black\")) |&gt; \nggplot(aes(x = somePFAS, y = Conc)) +\n  #geom_point(color = ~Color) +\n  geom_boxplot() + #ifelse(test, yes, no)\n  scale_color_identity() +  # Use scale_color_identity to override the default color mapping\n  theme_classic() +\n  ylab(\"Concentration of PFAS (ng/g) in solid samples\")\n\n\n\n\n\nggplot(data = PFAS_insects_long, aes(x = somePFAS, y = Conc)) +\n  #geom_point(color = ifelse(as.numeric(somePFAS) &lt; 0.007, \"orange\", \"black\")) +\n  #geom_boxplot() +\n  #scale_color_identity() +  # Use scale_color_identity to override the default color mapping\n  theme_classic() +\n  ylab(\"Concentration of PFAS (ng/g) in solid samples\")"
  },
  {
    "objectID": "Project.html#correct-the-instrumental-with-the-internal-standard-is",
    "href": "Project.html#correct-the-instrumental-with-the-internal-standard-is",
    "title": "8  Project",
    "section": "8.1 Correct the instrumental with the internal standard (IS):",
    "text": "8.1 Correct the instrumental with the internal standard (IS):\n\n#Clean the environment\nrm(list = ls()) \n\n#Load the libraries\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.4\n✔ ggplot2   3.4.3     ✔ stringr   1.5.0\n✔ lubridate 1.9.2     ✔ tibble    3.2.1\n✔ purrr     1.0.2     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(readxl)\nlibrary(patchwork)\n\n#Load the file\nGC_qToF_CPsFoodResults&lt;-read_excel(\"F:/OREBRO/CP analysis/Food project/Result/Skyline/GC_qToF_CPsFoodResults.xlsx\")\n\n#Wide the data so each sample is in one row\nGC_qToF_CPsFoodResultsB &lt;- GC_qToF_CPsFoodResults |&gt;  \n  filter(Quantitative == \"YES\") |&gt; \n  pivot_wider(id_cols = `Replicate Name`,\n              names_from = Molecule, # name of the new column\n              values_from = Area #name of the values for the new columns\n             ) #data type       \n\n#Make the data in the data frame numeric\npattern &lt;- \"^C\\\\d+\" # This pattern matches column names starting with \"C\" followed by numbers\nGC_qToF_CPsFoodResultsB &lt;- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), as.numeric) # Apply as.numeric() to columns matching the pattern\nGC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)# Define the IS as numeric \n\n#Divide the area of the homologues by the IS\nCorrectedArea &lt;- mutate_at(GC_qToF_CPsFoodResultsB, vars(matches(pattern)), \n                           ~ . / GC_qToF_CPsFoodResultsB$IS) #It will now do it for all the columns that have the pattern (start the name with \"C\")"
  },
  {
    "objectID": "Project.html#calculate-the-recovery",
    "href": "Project.html#calculate-the-recovery",
    "title": "8  Project",
    "section": "8.2 Calculate the recovery",
    "text": "8.2 Calculate the recovery\n\n# Define the RS as numeric\nGC_qToF_CPsFoodResultsB$RS = as.numeric(GC_qToF_CPsFoodResultsB$RS) \nGC_qToF_CPsFoodResultsB$IS = as.numeric(GC_qToF_CPsFoodResultsB$IS)\n\n##########Filter and prepare the standards that we want to compare to\nStd&lt;-GC_qToF_CPsFoodResultsB|&gt;  \n  select(`Replicate Name`, IS, RS)|&gt; #Select the columns that we need\n  filter(str_detect(`Replicate Name`, \"Std\", negate = FALSE))|&gt; #Select the standards\n  mutate(RatioStd = IS / RS) |&gt; #Calculate the IS/RS area for the standards \n  summarize(AverageRatio = mean(RatioStd, na.rm = TRUE)) #Calculate the average of the three standards\n\n##############Calculate the recovery\nGC_qToF_CPsFoodResultsB&lt;-GC_qToF_CPsFoodResultsB|&gt;\n  filter(str_detect(`Replicate Name`, \"9_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"10_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"11_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"12_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"13_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"14_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"15_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"16_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"17_\", negate = TRUE))|&gt;#Exclude the calibration standards\n  filter(str_detect(`Replicate Name`, \"Std\", negate = TRUE))|&gt;#Exclude the calibration standards\n  \n  mutate(RatioSample= IS / RS) |&gt; #Divide IS/RS for all samples\n  mutate(Recovery=RatioSample/as.numeric(Std))|&gt; #Divide each sample ratio of IS/RS by the average ratio of the standards\n  mutate(RecoveryPerc=Recovery*100) #The recovery in percentage\n\n\n#################Plotting the recovery\n\n# Define colors based on conditions: less than 50% red and above green\nGC_qToF_CPsFoodResultsB$color &lt;- ifelse(GC_qToF_CPsFoodResultsB$RecoveryPerc &gt; 50, \"#CD3333\", \"#9ACD32\")\n\n#Reorder the samples\nGC_qToF_CPsFoodResultsB$`Replicate Name` &lt;- factor(GC_qToF_CPsFoodResultsB$`Replicate Name`, levels = c(\"1\", \"1B\", \"1C\", \"2\", \"3\", \"4A\", \"4B\", \"5A\", \"5B\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"18\", \"19\", \"20\", \"D1\", \"D2\", \"D3\", \"21 Na2SO4\", \"23 24 FB\", \"25 LB\", \"26 LB\", \"27 LB\", \"28 LB\", \"29 MLB\"))\n\n# Bar plot\nggplot(GC_qToF_CPsFoodResultsB, aes(x = `Replicate Name`, y = RecoveryPerc, fill = color)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  scale_fill_manual(values = c(\"#CD3333\", \"#9ACD32\"), guide = FALSE) +\n  labs(x = \"Replicate Name\", y = \"RECOVERY\", title = \"RECOVERY\") +\n  theme_minimal()\n\nWarning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in\nggplot2 3.3.4.\nℹ Please use \"none\" instead."
  },
  {
    "objectID": "Project.html#prepare-the-single-chain-standards",
    "href": "Project.html#prepare-the-single-chain-standards",
    "title": "8  Project",
    "section": "8.3 Prepare the single chain standards",
    "text": "8.3 Prepare the single chain standards\nBefore quantifying PCAs in R by the deconvolution method, I need to prepare a “calibration” excel to input in the script. In this Excel one calibration curve is built by linear regression for each PCA homologue in each standard\n\n8.3.1 Build the calibration curves in R studio:\n\n#Load the file\n\nTESTING&lt;-read_excel(\"F:/LINKOPING/Manuscripts/Skyline/Skyline/TESTING.xlsx\")|&gt;\nmutate(`Analyte Concentration`= as.numeric(`Analyte Concentration`))\n\n######Build the calibration curve for one PCA homologue\nTESTING |&gt;\n  select(`Replicate Name`, Molecule, `Isotope Label Type`, `Normalized Area`, `Analyte Concentration`) |&gt;#Select the columns that we need\n  filter(`Isotope Label Type`== \"Quan\") |&gt; #Filter for the Quan\n  filter(`Molecule` == \"C11H19Cl5\")|&gt; #Filter for one PCA homologue\n  filter(str_detect(`Replicate Name`, \"11_57_\", negate = TRUE)) |&gt; #remove all the other standards \n\n  ggplot(aes(x = `Analyte Concentration`, y = `Normalized Area`)) + #Plot the scatter plot\n  geom_point() +\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = FALSE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n  theme_classic() +\n  ylab(\"Normalized Area\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n###################################################################################################################\n##############Normalized area is missing some values in the data frame so, I tried with the Area instead to see if the code was correct\n###################################################################################################################\n\n\nTESTING |&gt;  \n  select(`Replicate Name`, Molecule, `Isotope Label Type`, Area, `Analyte Concentration`) |&gt; #Select the columns that we need\n  filter(`Isotope Label Type`== \"Quan\") |&gt; #Filter for the Quan\n  filter(`Molecule` == \"C11H19Cl5\")|&gt; #Filter for one PCA homologue\n  filter(str_detect(`Replicate Name`, \"11_57_\", negate = TRUE)) |&gt; #remove all the other standards \n\n  ggplot(aes(x = `Analyte Concentration`, y = Area)) + #Plot the scatter plot\n  geom_point() +\n  geom_smooth(method = \"lm\", # uses the linear regression model\n              se = FALSE, # this will remove the confidence intervals\n              colour = \"orange\",\n              size = 2) +\n  theme_classic() +\n  ylab(\"Area\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n#################################################################################################################\n###################################Try to generate a loop for the calibration curve, so I don't need to write the homologue and the standards for every calibration curve###########################################################\n#################################################################################################################\n\n\n#Two standards per each molecule -&gt; each molecule one calibration curve for standard \"A\" and one for \"B\"\n\n###########CALIBRATION FOR STANDARDS \"A\" ##################################################\n\n# Function to create molecule names\ncreate_molecule_name &lt;- function(i, j) {\n  molecule_name &lt;- paste0(\"C\", i, \"H\", (2*i)+2-j, \"Cl\", j)\n  return(molecule_name)\n}\n\n# Create an empty list to store plots and calibration results\nplotsA &lt;- list()\ncalibration_resultsA &lt;- data.frame(STD_code = character(),\n                                  Reference_standard = character(),\n                                  Chain_length = character(),\n                                  Type = character(),\n                                  Homologue = character(),\n                                  Response_factor = numeric(),\n                                  Intercept = numeric(),\n                                  R_squared = numeric(),\n                                  stringsAsFactors = FALSE)\n\n# Define the range of i and j\ni_values &lt;- 11\nj_values &lt;- 3:11\n\n# Nested loops to iterate over i and j\nfor (i in i_values) {\n  for (j in j_values) {\n    # Create molecule name\n    molecule_name &lt;- create_molecule_name(i, j)\n    \n    # Filter data for the current molecule\n    filtered_dataA &lt;- TESTING |&gt;\n      filter(`Isotope Label Type` == \"Quan\", Molecule == molecule_name, Note == \"A\") \n    \n    # Check if there are any non-NA cases in the filtered data\n    if (sum(!is.na(filtered_dataA$Area)) == 0 || sum(!is.na(filtered_dataA$`Analyte Concentration`)) == 0) {\n      cat(\"No valid cases for fitting the model for molecule:\", molecule_name, \"\\n\")\n    } else {\n      # Fit linear model to the data\n      lm_modelA &lt;- lm(Area ~ `Analyte Concentration`, data = filtered_dataA)\n      \n      # Extract slope and intercept from the model\n      slopeA &lt;- coef(lm_modelA)[2]\n      interceptA &lt;- coef(lm_modelA)[1]\n      \n      # Calculate R-squared\n      R_squaredA &lt;- summary(lm_modelA)$r.squared\n      \n      # Store the calibration results in the data frame\n      calibration_resultsA &lt;- rbind(calibration_resultsA, \n                                   data.frame(Reference_standard = \"A\",\n                                              Chain_length = \"C\" [i],\n                                              Type = \"SCCPs\",\n                                              Homologue = molecule_name,\n                                              Response_factor = round(slopeA),\n                                              Intercept = interceptA,\n                                              R_squared = R_squaredA))\n    \n      # Create plot for the current molecule\n      plotA &lt;- ggplot(filtered_dataA, aes(x = `Analyte Concentration`, y = Area)) +\n        geom_point() +\n        geom_smooth(method = \"lm\", \n                    se = FALSE, \n                    colour = \"orange\",\n                    size = 1) +\n        theme_classic() +\n        ylab(\"Area\") +\n        ggtitle(paste(\"Molecule:\", molecule_name))\n      \n      # Store the plot in the list\n      plotsA[[paste(\"Molecule\", molecule_name)]] &lt;- plotA\n    }\n  }\n}\n\nNo valid cases for fitting the model for molecule: C11H21Cl3 \nNo valid cases for fitting the model for molecule: C11H14Cl10 \nNo valid cases for fitting the model for molecule: C11H13Cl11 \n\n# Print the data frame with calibration results\nprint(calibration_resultsA)\n\n                         Reference_standard Chain_length  Type Homologue\n`Analyte Concentration`                   A         &lt;NA&gt; SCCPs C11H20Cl4\n`Analyte Concentration`1                  A         &lt;NA&gt; SCCPs C11H19Cl5\n`Analyte Concentration`2                  A         &lt;NA&gt; SCCPs C11H18Cl6\n`Analyte Concentration`3                  A         &lt;NA&gt; SCCPs C11H17Cl7\n`Analyte Concentration`4                  A         &lt;NA&gt; SCCPs C11H16Cl8\n`Analyte Concentration`5                  A         &lt;NA&gt; SCCPs C11H15Cl9\n                         Response_factor   Intercept R_squared\n`Analyte Concentration`               55   -128.4533 1.0000000\n`Analyte Concentration`1            3504   7551.7035 0.8560300\n`Analyte Concentration`2          200370 -65240.9809 0.9953752\n`Analyte Concentration`3          111547 -69087.2219 0.5773315\n`Analyte Concentration`4           17456  -3024.9974 0.9960371\n`Analyte Concentration`5            -599   5506.1035 0.3937749\n\n# Arrange plots in a grid\ncalibration_curves_gridA &lt;- plotsA[[1]]\nfor (i in 2:length(plotsA)) {\n  calibration_curves_gridA &lt;- calibration_curves_gridA + plotsA[[i]]\n}\n\n# Print the grid of calibration curves\ncalibration_curves_gridA\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n###########CALIBRATION FOR STANDARDS \"B\" ##################################################\n\n# Function to create molecule names\ncreate_molecule_name &lt;- function(i, j) {\n  molecule_name &lt;- paste0(\"C\", i, \"H\", (2*i)+2-j, \"Cl\", j)\n  return(molecule_name)\n}\n\n# Create an empty list to store plots and calibration results\nplotsB &lt;- list()\ncalibration_resultsB &lt;- data.frame(Molecule = character(),\n                                  Slope = numeric(),\n                                  Intercept = numeric(),\n                                  R_squared = numeric(),\n                                  stringsAsFactors = FALSE)\n\n# Define the range of i and j\ni_values &lt;- 11\nj_values &lt;- 3:11\n\n# Nested loops to iterate over i and j\nfor (i in i_values) {\n  for (j in j_values) {\n    # Create molecule name\n    molecule_name &lt;- create_molecule_name(i, j)\n    \n    # Filter data for the current molecule\n    filtered_dataB &lt;- TESTING |&gt;\n      filter(`Isotope Label Type` == \"Quan\", Molecule == molecule_name, Note == \"B\") \n    \n    # Check if there are any non-NA cases in the filtered data\n    if (sum(!is.na(filtered_dataB$Area)) == 0 || sum(!is.na(filtered_dataB$`Analyte Concentration`)) == 0) {\n      cat(\"No valid cases for fitting the model for molecule:\", molecule_name, \"\\n\")\n    } else {\n      # Fit linear model to the data\n      lm_modelB &lt;- lm(Area ~ `Analyte Concentration`, data = filtered_dataB)\n      \n      # Extract slope and intercept from the model\n      slopeB &lt;- coef(lm_modelB)[2]\n      interceptB &lt;- coef(lm_modelB)[1]\n      \n      # Calculate R-squared\n      R_squaredB &lt;- summary(lm_modelB)$r.squared\n      \n      # Store the calibration results in the data frame\n      calibration_resultsB &lt;- rbind(calibration_resultsB, \n                                   data.frame(Molecule = molecule_name,\n                                              Slope = round(slopeB),\n                                              Intercept = interceptB,\n                                              R_squared = R_squaredB))\n      \n      # Create plot for the current molecule\n      plotB &lt;- ggplot(filtered_dataB, aes(x = `Analyte Concentration`, y = Area)) +\n        geom_point() +\n        geom_smooth(method = \"lm\", \n                    se = FALSE, \n                    colour = \"purple\",\n                    size = 1) +\n        theme_classic() +\n        ylab(\"Area\") +\n        ggtitle(paste(\"Molecule:\", molecule_name))\n      \n      # Store the plot in the list\n      plotsB[[paste(\"Molecule\", molecule_name)]] &lt;- plotB\n    }\n  }\n}\n\nNo valid cases for fitting the model for molecule: C11H21Cl3 \nNo valid cases for fitting the model for molecule: C11H20Cl4 \nNo valid cases for fitting the model for molecule: C11H13Cl11 \n\n# Print the data frame with calibration results\nprint(calibration_resultsB)\n\n                           Molecule  Slope    Intercept R_squared\n`Analyte Concentration`   C11H19Cl5    282    -100.5869 0.9985452\n`Analyte Concentration`1  C11H18Cl6  69945  -21222.1094 0.9982298\n`Analyte Concentration`2  C11H17Cl7 684163 -345883.4802 0.9899243\n`Analyte Concentration`3  C11H16Cl8 527969 -129197.1053 0.9984855\n`Analyte Concentration`4  C11H15Cl9 117684  -24610.5452 0.9985014\n`Analyte Concentration`5 C11H14Cl10   8784   -3011.7311 0.9939191\n\n# Arrange plots in a grid\ncalibration_curves_gridB &lt;- plotsB[[1]]\nfor (i in 2:length(plotsB)) {\n  calibration_curves_gridB &lt;- calibration_curves_gridB + plotsB[[i]]\n}\n\n# Print the grid of calibration curves\ncalibration_curves_gridB\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: Removed 1 rows containing non-finite values (`stat_smooth()`).\nRemoved 1 rows containing missing values (`geom_point()`).\n\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n8.3.2 The code for Excel:\n\n#Response factor of each homologue per 1 ng/µL\n#=ROUND(SLOPE(INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-10+MATCH(MAX(N4:U4);N4:U4;0));TRUE);INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MIN(N4:U4);N4:U4;0));TRUE):INDIRECT(ADDRESS(ROW();COLUMN()-18+MATCH(MAX(N4:U4);N4:U4;0));TRUE));0)\n############Note: N4:U4 are the values of the corrected peak are of the standards\n\n\n#The result from the previous row to this one\n#=IF(ISERROR(W4);0;W4)"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  }
]